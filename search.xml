<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2018总结</title>
    <url>/2019/01/31/2018%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2018 涵盖了大三大四两个学期，在整个大学 4 年中对我来说意义比较重大，事情也比较多，总觉得应该写点什么 ，也能作为后面的回忆吧。</p>
<span id="more"></span>

<h1 id="带队刷怪"><a href="#带队刷怪" class="headerlink" title="带队刷怪"></a>带队刷怪</h1><p>大二大三在校实验室呆了两年，算是前端开发的入门阶段。实验室只是学校的统称，我们实验室更确切的应该算是一个工作室。我在大二阶段就在学长学姐的带领下学习 web 开发相关的内容，大三了就带学弟学妹开发…</p>
<p>实验室维护着一个核心项目<a href="http://www.thumbclass.com/">拇指课堂</a>，因为前端技术栈比较落后，加上当时写的比较混乱，已经在不可维护的边缘了，所以导师找我们商量着更新一下技术栈（ionic1 到 ionic3）这个更新基本是重写…众所周知 Angularjs 和 Angular 是俩个框架（angular1.x 统称为 angularjs，angular2+统称为 angular，1 到 2 是个不兼容更新，基本可以认为 ng1 和 ng2 是两框架。后面的 ng2+ 都是在 ng2 基础上升级，是平滑更新），而 ionic1 用的 ng1，ionic3 用的 ng4。所以这套技术栈升级就是看着 UI 重写一遍…</p>
<hr>
<p>2018-01-22，在 thumbclass3.0 项目中提交了第一个 commit，</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">94b9017     You, a year ago   (January 22nd, 2018 1:25pm)</span><br><span class="line"></span><br><span class="line">Initial commit</span><br></pre></td></tr></table></figure>

<p>随后，便用了一个寒假时间带着学弟学妹们一起将拇指课堂学生端完成了。整个过程按着 Angular 的官网给的最佳实践控制文件结构和代码风格。这段时间是我能力的一个小跨越（还有个大跨越是实习阶段），因为这个 thumbclass3.0 算是自己从 0 开始的项目，开发中遇到的大大小小的问题也主要由我来处理，甚至一些概念也是我学完了再去教学弟学妹（Promise，Rxjs 等）。在给他们讲的时候自己对某些知识点的了解也会更深入（偶尔还会有他们提出一个问题也是我没考虑到的，大家一起 google 一起学习的情况）。在技术分享和项目的双重刺激下，我的能力也飞速上升，还荣获傅老师的称呼 23333</p>
<p>大三上开始就进行了教师端的改写，如果说学生端部分是一起学习一起进步的话，那教师端部分我就有点偏向管理。因为有学生端改写的经验，大家都已经轻车熟路，我的主要任务就从和大家一起完成项目变成组织大家更好更快地完成项目。教师端改写这几个月我组织大家每周进行技术分享，偶尔也开个项目会议了解下大家的进度（这时还没有软件过程的概念），遇到什么问题大家讨论解决有什么技术难题就 google 解决。。。在 ionic3 上也踩了不少坑，都记录在项目文档中（项目之初特地建了个 doc 目录用来放各种文档）</p>
<hr>
<p>2018-07-02，在 thumbclass3.0 项目中提交了最后一个 commit，</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ccc4da7     You, 7 months ago   (July 2nd, 2018 6:58pm)</span><br><span class="line"></span><br><span class="line">修改dismissAll为dismiss</span><br><span class="line">修复页面多次跳转的bug</span><br></pre></td></tr></table></figure>

<p>其实开发部分早就完成了，只是一直在做一些修修补补的事，比如补了一下项目交接的文档，补了一下 单元测试、e2e 测试，就是各种测试，包括一些自动化测试和手动点点点…修复了一些 bug 改善了一些体验上的问题，然后部署到了测试服，算是进入了内测阶段吧…</p>
<p>这一段带队刷怪的经历让我学到不少，尤其是解决问题部分，能熟练 google 出想要的答案，当然这也算一个不错的项目经历。另外，早就知道学校实习计划的我便早早地开始了准备，期间看了《JavaScript 高级程序设计》、《你不知道的 js》、《css 世界》等书，并在 3 月份就顺利获取了有赞实习的机会（提前占坑，7 月份去实习）</p>
<h1 id="新的征程"><a href="#新的征程" class="headerlink" title="新的征程"></a>新的征程</h1><p>虽然学校给的实习时间是 9-12，但我 7 月就去有赞实习了，毕竟早点去就多学点。刚进有赞实习心情是很愉悦的，然后实习生就给配 mac 也让我小小的惊讶了下（后面我面了好多公司正式员工给配的也不多）。职场小白表示对一堆术语一脸懵逼比如 QA，pre，prd，然后一开始的环境配置也很让人绝望，还有各种权限申请之类的。比如测试服务器部署权限（测试是没空给你部署环境的，他们只管测），发布上线权限，代码仓库权限 balabala…</p>
<p>由于有赞技术栈是 PC：React、h5:Vue、小程序：原生、node：Astroboy（内部基于 koa 二次开发的框架），可以说完美避开了我的技术栈（Angular、express）所以在有赞的半年也是飞速上升的半年，不仅是项目经验上，更是技术上…比如一天入门 react 啦，一周就上手项目开发，顺便看完了 React 官网文档和《深入浅出 React 与 Redux》,虽然有赞内部（几乎）不使用 Redux，加上几乎是因为不限制，你爱用就用，大多数情况下没必要，因为 PC 上是多页中的单页架构，所以每个单页都不是很复杂。</p>
<p>我虽然是在 PC 组但是因为业务比较复杂，所以 10 月份开始我的工作重心就在 h5 和小程序上了（因为内部还是按业务分的，我是做会员相关的所以 h5 和小程序的个人中心也在我们这边了）于是又看着 Vue 和小程序官网把这两框架学了下。有一点要说明的是，有赞面试的时候问的都是 html&#x2F;js&#x2F;css，js 偏多也比较深入，框架相关的啥也没问（大概当时看我的简历完美避开了他们技术栈所以没问吧…），所以 React 啊 Vue 啊我都是从 0 学起。之前在实验室写了一年 Angularjs 一年 Angular，学别的框架还是比较轻松的，无非就是一些模版一些数据一些样式。就是 jsx 这个东西感觉比较新奇，别的也没啥…</p>
<p>然后就是各种会议，项目评审、技术评审、测试用例评审、周会、站会、项目发布计划回滚计划等。还会遇到一天白天都在开完晚上码会儿代码等情况比较难受…还会有各种线上 bug 报过来跟进，不是自己的再转给别人。很少有一大段时间可以用于开发，iterm&#x2F;vscode 同时打开 4、5 个窗口是日常…</p>
<p>总结一下在有赞的收获，</p>
<ol>
<li>了解了各个环境的区别以及必要性。开发环境，测试环境，预发环境，线上环境。然后有赞有个 zan-proxy 用于吧某个 url 对应的页面代理到本地，对于开发提供了极大方便。</li>
<li>熟悉了项目的开发流程，立项-项目评审-技术评审-排期-开发-测试用例评审-提测-预发验收-上线。</li>
<li>学会了看源码，学会了在 node_modules 里 debug。</li>
<li>扩充了下技术栈，前端三大框架也终于都有所涉及了，然后对 node 的使用更顺畅了，顺便写了点小程序。</li>
<li>对前端的技术架构有了更深入的理解，毕竟有赞开放几乎所有的代码仓库，所以有些底层框架的代码也看了很多。</li>
</ol>
<h1 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h1><p>虽然因为种种原因从有赞离开了，但这半年的实习是我提高最快的半年，大学的最后一学期就在做毕设找工作中度过了。2018 总结就是成长、充实。2019 虽然遇上寒冬但是春天也不会遥远。</p>
<p>最后给 2019 立几个 flag 吧</p>
<ol>
<li>一个月看完一个 npm 包的源码，并留下笔记。</li>
<li>一季度看完一本书。</li>
<li>学习 webGL，做一个 3D 游戏出来。</li>
</ol>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>MEAN stack的点点滴滴</title>
    <url>/2017/11/03/MEAN-stack%E7%9A%84%E7%82%B9%E7%82%B9%E6%BB%B4%E6%BB%B4/</url>
    <content><![CDATA[<p>一个简单的关于MEAN.js的分享（入门教程）</p>
<span id="more"></span>

<hr>
<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>写在前面：<br>Angular自从出2.x版本后1.x就统称为Angularjs，2以及后面的版本称为Angular<br>另外Angularjs将在未来停止更新，本文基于Angularjs，所以前端部分的写法不用深究，其他内容换成Angular后也可以使用。</p>
<h2 id="MEAN-js简介"><a href="#MEAN-js简介" class="headerlink" title="MEAN.js简介"></a>MEAN.js简介</h2><p><strong>MEAN</strong>是一个以JavaScript语言主导的web开发技术栈。是MongoDB、Express、AngularJS、Nodejs的首字母缩写的组合。前端部分为Google提供的开源框架AngularJS（2.0开始做了不兼容升级并改名为Angular，这里以AngularJS为例，因为我们实验室主导项目基于AngularJS的，还没完成升级。）后端部分用Nodejs自带的http模块开启一个服务器，并用Express框架提供的中间件设计完成后端逻辑。其中数据持久化使用了一种noSQL数据库MongoDB。</p>
<p><strong>AngularJS</strong>是一个前端MVC框架，主要用于做单页应用（SPA，Single Page Application）。单页应用，顾名思义就是只有一个页面，里面所有的内容都是通过js动态请求数据并动态修改HTML的DOM实现的。</p>
<p><strong>Nodejs</strong>是JavaScript的一个运行环境，由Google的V8引擎提供了js解析，让js可以脱离浏览器运行，并提供了一些系统api比如文件读写（fs模块），内置了一个http模块提供服务器支持（C++编写，效率保证）我们要使用它需要安装，网上可以找到安装程序，装完后可以通过<code>node -v</code>查看版本</p>
<p><strong>Express</strong>是后端框架，作为Nodejs http模块的server中间件处理分发请求。</p>
<p><strong>MongoDB</strong>是文档型数据库，内部数据为json结构，不用再进行对象的二次转换，使用很方便，效率也蛮高，比较适合数据变化较大，数据结构较复杂的网页。</p>
<p>以上只是极简单的介绍，详情可以自行参考各框架的官网~</p>
<h2 id="以一个小项目为例"><a href="#以一个小项目为例" class="headerlink" title="以一个小项目为例"></a>以一个小项目为例</h2><p>接下来以一个时间表小项目为例，记录下从０开始的编码过程。这个项目主要用于记录一周７天ｘ上午下午晚上３个时间段的空闲时间（实验室要求每个人规划自己的空闲时间提交来实验室的时间）。核心就两个模块，时间表模块和用户模块。时间表就增改查，用户就登录注册。出于演示所有功能逻辑都只是一个雏形．．．<br>然后说一下我的环境，为了适应生产环境，我本地环境是node6.10.0，npm3.10.10至于npm是啥下文会讲。</p>
<hr>
<h1 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h1><h2 id="Nodejs建立服务器"><a href="#Nodejs建立服务器" class="headerlink" title="Nodejs建立服务器"></a>Nodejs建立服务器</h2><p>首先提一下模块系统，我们自己开发的网页会用到很多别人写的库或者框架，要是全部以源码方式交流（git等方式团队合作）代码文件就很大，而且满大街找别人写好的东西也很累是不（笑），所以就有了模块系统也就是npm这个东西。在安装完nodejs后npm也一起装完了，npm就是一个nodejs的模块管理工具，官方一点就是包管理器。你需要下载一个什么东西直接<code>npm install xxx</code>就好了，是不是超级方便，执行完后当前目录下（当前目录就是你命令行执行那个命令的目录，“&gt;”左边那个东西，windows下按win+r输入cmd就打开了命令行，默认在用户目录“<code>C:\Users\你的用户名</code>”）就会有一个<code>node_modules</code>文件夹，下载的所有库都会在那里面。那么要是团队合作怎么知道我装了什么库呢？一般人都能想到，写一个文件记录装的库名字和版本号不就行啦，这就是<code>package.json</code>文件。当然package.json文件记录了更多的信息，比如项目名字，作者，开源协议等稍后再细讲。</p>
<p>好了进入正题。win+r输入cmd进入命令行(一个黑框框)，输入<code>cd Desktop</code>回车，工作路径切换到桌面（下文“执行xxx”就表示命令行输入命令后回车）执行<code>mkdir timetable</code>，桌面会新建一个timetable文件夹。执行<code>cd timetable</code>，<code>npm init</code>，然后会问我们好多问题，暂时全部保持默认一路回车（之后再改）。最后出现Is this ok? (yes)回车之后timetable文件夹就出现了package.json文件。我的文件长这样</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;timetable&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>当然刚刚那一堆命令也不用那么烦，你完全可以把上面这段代码复制，本地保存为package.json然后新建个timetable文件夹吧package.json扔里面，效果完全一样。</p>
<p>package.json是nodejs项目的模块配置文件，执行npm相关命令的时候都会读取或者写入这个文件，上文提到的把依赖的库名称和版本号记录下来也是在这个文件里面。<br>在timetable文件夹下新建<a href="http://www.js,编写如下代码/">www.js，编写如下代码</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">write</span>(<span class="string">&#x27;hello nodejs&#x27;</span>);</span><br><span class="line">    res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>回到命令行（希望你没有关，关了也没事，打开timetable文件夹，在不选中任何文件的情况下按住shift后按鼠标右键会发现右键菜单多了“在此处打开命令窗口”的选项，也可能是“在此处打开powershell窗口”…win10不太一样，点一下就打开在timetable目录的命令行了，当然你要通过cd切换我也没意见）执行<code>node www</code>，然后打开浏览器输入<code>http://localhost:8080</code>就可以看到输出了。这样就用nodejs很简单的建立了一个本地服务器，监听8080端口。</p>
<h2 id="后端基本结构"><a href="#后端基本结构" class="headerlink" title="后端基本结构"></a>后端基本结构</h2><p>这样虽然开启了了服务器，并且也可以成功收到请求了，但是若是所有的请求都在一个函数里面执行逻辑，比如判断请求参数调用不同函数，那将是一个灾难（虽然用一个map似乎也不是不可以，但是我们有更好的方案）。然后执行<code>npm i --save express</code>引入<code>express</code>框架（如果你的命令行正在执行node你可以选择<code>ctrl+c</code>终止或者另外再开一个命令行）。这里i就是install的缩写，<code>--save</code>就表示吧这个库连同版本号一起写入package.json文件中。下载完依赖后打开package.json，会发现多了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;express&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.16.2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这就记录了这个项目依赖<code>express</code>这个框架（库），版本号为4.16.2。这样会安装最新版本，如果要装确定的版本，就在库名后面加上@版本号就行了比如<code>npm i --save express@4.0.0</code>（这个版本号瞎编的，实际中需要去官网看需要哪个版本），别人拿到项目后也不用一个个<code>npm i xxx</code>了可以直接运行<code>npm i</code>，npm会读取<code>package.json</code>文件里含有<code>dependencies</code>字段的内容并全部下载（除了dependencies，常用的还有devDependencies等，区别后面会讲）</p>
<p>好了我们继续，打开并修改<a href="http://www.js文件(加了相关注释)/">www.js文件（加了相关注释）</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 实例化express</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 用express的实例app创建一个服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(app);</span><br><span class="line"><span class="comment">// 监听8080端口</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br><span class="line"><span class="comment">// 监听对根目录的get请求</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>重启下服务器（ctrl+c终止后按↑就可以看到历史命令，找到node www后回车）每次对代码进行修改都要重启下服务器让内的代码进入内存（node会吧代码放到缓存，从缓存读取）然后刷新下浏览器，应该可以看到效果了，为了区分我把hello nodejs改成输出hello express。对比下两个<a href="http://www.js文件,其实就是`createserver`函数的参数用express的实例app代替了,而后面加了个app.get函数用于处理对“/%E2%80%9D%E7%9A%84get%E8%AF%B7%E6%B1%82%E3%80%82%E8%87%B3%E4%BA%8Eget%E8%AF%B7%E6%B1%82%E5%95%A5%E6%84%8F%E6%80%9D%E5%BB%BA%E8%AE%AE%E8%A1%A5%E4%B8%80%E4%B8%8Bhttp%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%EF%BC%88%E6%89%BE%E5%87%A0%E7%AF%87%E5%8D%9A%E5%AE%A2%E7%9C%8B%E4%B8%80%E4%B8%8B%E5%B0%B1%E5%A5%BD%EF%BC%89">www.js文件，其实就是`createServer`函数的参数用express的实例app代替了，而后面加了个app.get函数用于处理对“/”的get请求。至于get请求啥意思建议补一下http协议相关内容（找几篇博客看一下就好）</a></p>
<p>有了这个就方便多了，我们可以简单的往下加app.get或者post来处理不同的请求。<a href="http://www.js文件最后面加上/">www.js文件最后面加上</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/timetable&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;timetable&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>重启node服务后访问<code>localhost:8080/user</code>和<code>localhost:8080/timetable</code>就可以看到效果了。然后是不是觉得重启每次改完代码都要重启下服务很烦？那就需要一些工具了。命令行执行<code>npm i --save-dev supervisor</code>。这回出现了个新东西<code>--save-dev</code>这个和上面出现过的<code>--save</code>是差不多的，只不过这样就把依赖写入package.json的devDependencies字段里面，表示这个依赖开发的时候才用得到，生产环境不需要。这样生产环境执行<code>npm install --production</code>就不会下载安装devDependencies下的东西。此时package.json文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;timetable&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;express&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.16.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;supervisor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.12.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这时候就可以使用<code>supervisor www</code>代替<code>node www</code>了，supervisor会自动监听文件，有改动就自动重启。然后我们发现supervisor这个单词好长，教练，有没有简单的命令？当然有。package.json有一个scripts字段，目前里面只有<code>&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</code>，我们加上<code>&quot;start&quot;: &quot;supervisor www&quot;,</code>，现在package.json的scripts变成了这样</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;supervisor www&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>然后就可以用<code>npm run start</code>代替<code>supervisor www</code>命令了，然后npm对start做了简化可以直接写<code>npm start</code>（具体关于这部分内容可以看<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html">这里</a>），好了我们执行<code>npm start</code></p>
<p>继续。随着项目变大，代码全部写在www文件会导致文件越来越大。是时候做一波代码分离了。首先吧app和www分离，后续代码基本不会修改www里面的内容了，就是app内容的修改（多写几个app.get等…)好，首先新建个app.js并把<code>www.js</code>里面关于app的代码分离出去，然后新建个bin文件夹，表示可执行目录，并把<a href="http://www.js文件拖进去,之后所有可执行文件都会放在bin目录(有些项目会有定时任务啥的要单独执行)/">www.js文件拖进去，之后所有可执行文件都会放在bin目录（有些项目会有定时任务啥的要单独执行）</a>…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 实例化express</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/timetable&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;timetable&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bin/www.js</span></span><br><span class="line"><span class="comment">// 引入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入app模块</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;../app&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用express的实例app创建一个服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(app);</span><br><span class="line"><span class="comment">// 监听8080端口</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>解释一下，这里把app相关的代码分离到了app.js，<a href="http://www.js的app就引入(因为app在父目录所以是`../app.js%60%EF%BC%89%E5%B0%B1%E5%A5%BD%E4%BA%86%E3%80%82%E7%84%B6%E5%90%8E%E5%9B%A0%E4%B8%BA%E8%A6%81%E6%8F%90%E4%BE%9B%E7%BB%99www%E6%96%87%E4%BB%B6%E5%BC%95%E5%85%A5%E6%89%80%E4%BB%A5app%E6%96%87%E4%BB%B6%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%60module.exports">www.js的app就引入（因为app在父目录所以是`../app.js`）就好了。然后因为要提供给www文件引入所以app文件最后一行`module.exports</a> &#x3D; app;&#96;就表示把app模块导出（这里是CommonJS规范的模块语法）。<br>然后我们对bin&#x2F;<a href="http://www.js文件做最后的改动，把端口号定义成常量然后server绑定了listening和error事件（用于报告错误，具体事件代码我是直接复制IDEA生成的express项目代码的）：">www.js文件做最后的改动，把端口号定义成常量然后server绑定了listening和error事件（用于报告错误，具体事件代码我是直接复制IDEA生成的express项目代码的）：</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bin/www.js</span></span><br><span class="line"><span class="comment">// 引入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入app模块</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">&#x27;../app&#x27;</span>);</span><br><span class="line"><span class="comment">// 定义端口常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PORT</span> = <span class="number">8080</span>;</span><br><span class="line"><span class="comment">// 用express的实例app创建一个服务</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(app);</span><br><span class="line"><span class="comment">// 监听8080端口</span></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="variable constant_">PORT</span>);</span><br><span class="line"><span class="comment">// 绑定成功监听端口事件</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;connect to port &#x27;</span> + <span class="variable constant_">PORT</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 绑定错误事件</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (error.<span class="property">syscall</span> !== <span class="string">&#x27;listen&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> bind = <span class="keyword">typeof</span> port === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">        ? <span class="string">&#x27;Pipe &#x27;</span> + port</span><br><span class="line">        : <span class="string">&#x27;Port &#x27;</span> + port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (error.<span class="property">code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;EACCES&#x27;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(bind + <span class="string">&#x27; requires elevated privileges&#x27;</span>);</span><br><span class="line">            process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;EADDRINUSE&#x27;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(bind + <span class="string">&#x27; is already in use&#x27;</span>);</span><br><span class="line">            process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后我们可以不用管www文件了。把重点放到app文件，首先就是那几个app.get。之前演示已经知道了这个是绑定路由，根据前端请求的路径执行不同的函数实现后端数据处理逻辑。那么当项目越来越大以后，这样子的函数就会越来越多，都放到app.js显然不是很合适，是时候做一波路由分离了（这个名词我瞎编的0.0）</p>
<p>首先新建一个<code>routes</code>文件夹里面再新建<code>index.js</code>，<code>user.js</code>，<code>timetable.js</code>。然后把app.get相关代码转移过去。那么问题来了，怎么转移？之前把app从www转移是因为app完全是分离的代码，www里面的app可以导入app并且没有别的操作了。然而我们这里要把app.get转移出去的话index.js文件里面的app的确也可以导入，但是在routes&#x2F;index.js文件写好的代码怎么导入到app.js文件呢？直接require么？那不是循环依赖了（routes&#x2F;index.js require app，app.js又require routes&#x2F;index.js）一个可行的方案是routes&#x2F;index.js导出一个可执行函数并接受app作为参数，在app.js里面直接require并执行。示例代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>改成这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>)(app);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/index.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">app</span>) &#123;</span><br><span class="line">    app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这么做的缺点这是把app整个根模块暴露给了项目的子模块，就有可能造成app模块的滥用导致影响别的代码，或者说，增强了模块的耦合。<br>不过在express4.x开始引入了一个Router，于是分离路由有了新方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>改成这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, index);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>这两种方式没什么本质的区别，app本质上也只是一个router而已，这里用了express.Router挂载路由，后面的get啊post啊都加到router上面，独立了一个路由的实例，具体有什么好处可以查看这篇文章<a href="http://lostjs.com/2014/04/24/router-in-express-4/">浅谈 Express 4.0 Router 模块</a>。这里有个地方需要注意的，现在无论app.get还是app.use还是router.get第一个参数都是“&#x2F;”，看不出啥问题，但是要是换成“&#x2F;user”就有区别了。下文细讲<br>完整的分离后的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 实例化express</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 引入别的路由模块</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">&#x27;./routes/user&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> timetable = <span class="built_in">require</span>(<span class="string">&#x27;./routes/timetable&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, index);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/user&#x27;</span>, user);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/timetable&#x27;</span>, timetable);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hello express&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/timetable.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;timetable&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>首先会发现<code>index.js</code>，<code>timetable.js</code>，<code>user.js</code>三个文件内部的get第一个参数都是“&#x2F;”而不是“&#x2F;user”啥的。看<code>app.js</code>用了app.use。就是使用中间件，具体这个啥意思目前可以理解为对第一个参数的路由的请求都由第二个参数的模块处理，比如<code>app.use(&#39;/user&#39;,user)</code>表示对<code>/user</code>路径的请求都会由user模块处理，那么<code>/user</code>的请求就是<code>user</code>模块的<code>/</code>对应的函数处理。<br>在routes&#x2F;user.js加一个路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;user&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;user2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>它本身在<code>app.js</code>就挂在到<code>/user</code>下了，内部再router.get(‘&#x2F;user’)，所以对应到路由就是访问<code>localhost:8080/user/user</code>才能看到user2的输出。另外可以看到后面的function有三个参数，req，res，next。分别对应请求体，相应体和下一个函数。这里先解释下next这个参数<br>修改routes&#x2F;user.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    req.<span class="property">user</span> = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">    res.<span class="property">user</span> = <span class="string">&#x27;bbb&#x27;</span>;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;user name &#x27;</span> + req.<span class="property">user</span> + res.<span class="property">user</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>我们写了两个router.get(‘&#x2F;‘)的函数，路由会先找到第一个执行后再找到第二个继续执行，所以访问<code>localhost:8080/user</code>就会显示<code>user name aaabbb</code><br>这里第一个&#x2F;就可以理解为一种预处理。可以试试吧第一个&#x2F;的函数的next()删了看看会发生什么，或者吧next()改成<code>res.send(&#39;user&#39;)</code>看看页面显示啥。</p>
<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><p>前面写了那么多所谓的路由都是发送一串字符串，那我需要发送一个页面什么的怎么办呢？首先我们可以先尝试下<br>修改index.js代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/index.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;&lt;h1 style=&quot;color: red&quot;&gt;hello express&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>访问<code>http://localhost:8080</code>看看页面输出了什么？是不是h1标签的大小以及样式都应用上了？其实我们发送的不是一个严格的html文件，但是浏览器当做html解析了。那我们要发送好看的首页带css样式再加点js效果那不是字符串拼接要累死人了？别慌express帮我们搞定了，而且只需要一点点代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// 引入path</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 实例化express</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 引入别的路由模块</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">&#x27;./routes/user&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> timetable = <span class="built_in">require</span>(<span class="string">&#x27;./routes/timetable&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置静态资源路径，express自动处理get请求</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>)));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, index);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/user&#x27;</span>, user);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/timetable&#x27;</span>, timetable);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app;</span><br></pre></td></tr></table></figure>

<p>就加了两行<code>const path = require(&#39;path&#39;);</code>和<code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));</code>。然后根目录下新建public文件夹，里面再新建一个index.html，写入点简单的代码<br>public&#x2F;index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>timetable<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Time Table<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> h1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(h1);</span></span><br><span class="line"><span class="language-javascript">    h1.<span class="property">innerHTML</span> += <span class="string">&#x27;123&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打开浏览器<code>http://localhost:8080</code>就可以看到效果啦。好了，解释下上面加的那些代码的意义，html文件就不解释了。。。主要是<code>app.js</code>里面加的<code>const path = require(&#39;path&#39;);</code>和<code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));</code>第一句就是引入path依赖，它是nodejs自带的一个模块，会自动处理文件路径拼接的符号问题。比如用字符串拼接’a&#x2F;‘+’&#x2F;b就是’a&#x2F;&#x2F;b’这个路径就会出错，但是path.join(‘a&#x2F;‘, ‘&#x2F;b’)结果就是’a\b’。（可以执行下routes&#x2F;test.js看看输出结果）。这里顺便解释了后面那一句<code>path.join(__dirname, &#39;public&#39;)</code>的意思，就是把<code>__dirname</code>和<code>public</code>两个路径拼起来，至于<code>__dirname</code>就是项目路径名，nodejs全局定义的一个变量。然后继续往外解释<code>express.static(path.join(__dirname, &#39;public&#39;))</code>。外面的express.static就是设置静态文件路径，最后用app.use引入到项目，这句话整个的意思就是把public目录下的文件都设置成静态文件，所有的请求都先去public下找一遍，并且吧对<code>/</code>目录的请求绑定为<code>public/index.html</code>。所以加了这一句，nodejs对于网页发出的所有请求都会先去public目录找一遍，找到就返回那个静态文件，没找到就进入下一步逻辑。</p>
<p>举个例子，在public目录下新建一个123.txt，里面随便打点东西比如我打了“123”。打开浏览器，输入<code>localhost:8080/123.txt</code>我们发出了一个对123.txt的请求，可以看到浏览器显示了这个文件的内容。所以，对于浏览器的请求，node就会在app文件里面绑定的路由（app.use或者app.get app.post）一个个找下来，找到了就执行相关逻辑（或者直接返回静态文件）没找到就出错啦。所以我们在<code>app.js</code>最后加上两个错误处理的函数（放在<code>app.js</code>的最后一行的上面，虽然放最后也无所谓，但是这样美观一点0v0）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;404 NOT FOUND！&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个就是处理所有的路由都没有找到的情况，这里使用了use没有第一个参数，直接就是一个function，表示所有的请求都会经过它。访问一个不存在的路由就可以看到效果，比如<code>localhost:8080/aaa</code>就可以看到页面显示“404 NOT FOUND！”，因为前面所有路由都没有匹配的话就会走到最后一个app.use（就是之前刚加的那个。）<br>这个和<code>app.use(express.static(path.join(__dirname, &#39;public&#39;)));</code>是一样的，所有的请求都会经过那个中间件，而<code>express.static()</code>最后返回的也是一个类似于<code>function (req, res, next)</code>这样的函数。所以我们可以了解到，express的前后端分离核心就是这一句，把public目录设置成静态文件目录导致浏览器所有请求会优先去public文件夹下寻找对应的文件，找到就返回。那么public目录就是前端的目录，前端使用html文件编写，可以直接返回并由浏览器渲染。</p>
<hr>
<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="前端基本结构"><a href="#前端基本结构" class="headerlink" title="前端基本结构"></a>前端基本结构</h2><p>前面已经讲了public目录就是静态文件目录也就可以理解为前端目录，并且已经新建了两个文件作为例子(<code>index.html</code>和<code>123.txt</code>)。现在我们把文件结构建完整。在public文件夹下面新建文件夹<code>css</code>,<code>js</code>,<code>img</code>,<code>lib</code>,<code>font</code>，（这里我为了让GitHub不忽略他所以某些文件夹加了个<code>.gitkeep</code>文件，因为GitHub会忽略空文件夹，虽然理论上里面放个什么文件都可以，但是大家还是约定成<code>.gitkeep</code>文件。）然后随便写点东西，先把一开始建立的index.html文件的css部分和js部分分离。在css文件夹下新建index.css，js文件夹下新建index.js。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* public/css/index.css */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public/js/index.js</span></span><br><span class="line"><span class="keyword">const</span> h1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;h1&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(h1);</span><br><span class="line">h1.<span class="property">innerHTML</span> += <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>分离css和js后的html文件public&#x2F;index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>timetable<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Time Table<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里我们可以看到<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;</code>这个link标签的href直接引入了相对路径下的css。因为这个请求发送实质是一个对 <code>localhost:8080/css/index.css</code>的GET请求，所以服务端直接处理并返回了静态文件。由此也可以进一步确定public目录下的所有文件就是一个前端的工程项目。后端会自动发送相应请求文件。</p>
<h2 id="AngularJS：MVC"><a href="#AngularJS：MVC" class="headerlink" title="AngularJS：MVC"></a>AngularJS：MVC</h2><p>前端结构建好了就进入开发了，前端框架选择的是AngularJS，先引入文件（因为后续要使用webpack所以这里我们采用网络上的文件引入，所以确保自己联网。）<br>这里我们找了个AngularJS1.6.6版本的CDN引入。(CDN这里可以简单理解为别人存在网络上的文件我们可以直接用)。修改index.html文件（注：以下操作全部在public文件夹下，所以提到文件名都不说具体目录了，全部都在public或者它的子目录下的文件）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>timetable<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Time Table<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;双向绑定测试&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/angular.js/1.6.6/angular.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改index.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [])</span><br></pre></td></tr></table></figure>

<p>这里不会讲太多AngularJS的概念（可以参考官网或者哪天我有空了再写相关文章…）只会说一些我们实验室的开发流程。</p>
<p>首先AngularJS就是一个库，和JQuery一样的方式引入就好了，这里是<code>script</code>标签的<code>src</code>引入了一个网上的库。然后我们在body标签里面加了一个<code>ng-app=&quot;app&quot;</code>，然后js的代码<code>angular.module(&#39;app&#39;, [])</code>就申明了一个模块，<code>angular.module</code>这个函数接受两个参数，第一个是模块名，第二个是依赖名，第二个参数啥意思后面会介绍，现在因为我们没有别的依赖所以就让第二个参数为空数组。第一个参数的模块名就是对应页面上的<code>ng-app</code>的值，告诉AngularJS这个是一个模块名字叫做app(ng-app的等号后面的值)，所以页面上的ng-app后面的值要和js里面的angular.module的第一个参数一样，不然会出错。这里就叫app了。因为angular主要是单页应用的框架，所以只会有一个主html文件（就是包含head body等标签的html），别的代码都是以html片段的形式存在，在angular需要时会动态加载进来替换掉页面上的部分DOM结构。</p>
<p>解释完了我们写的代码，可以打开浏览器看看效果。我们发现在input框里输入的内容都会在后面出现。这里就是双向绑定的概念了，回到代码，发现我们在input框加入了<code>ng-model=&quot;name&quot;</code>，然后后面又加了<code>{{name}}</code>、<code>ng-model</code>的意思是把输入框的值和后面那个变量进行绑定<code>{{}}</code>的意思是把变量进行输出。这样input的内容有修改的话就可以实时在内存中变化了。同理要是内存中的变量变化了也会在input中显示（比如js代码修改了变量值）说说不解释概念还是废话了一堆..</p>
<p>刚刚提到内存中的变量，可能对这个概念有点懵逼，现在我们加上controller，就会对这个概念有点了解了。<br>修改index.html的一部分代码（就是div 标签上加了一个<code>ng-controller=&quot;appCtrl&quot;</code>）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;appCtrl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;双向绑定测试&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改index.js，定义一个controller（就是那个<code>.controller</code>），名字为appCtrl（第一个参数，是个字符串），第二个参数就是这个controller的内容（是个函数）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope</span>) &#123;</span><br><span class="line">        $scope.<span class="property">name</span> = <span class="number">123</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p><code>ng-controller</code>就是一个控制器，控制器是什么概念呢？简单理解下就是和页面绑定在一起的数据，比如页面里面的文字，输入框里面的内容，甚至是一个按钮的点击事件对应（绑定）的函数。为什么要叫控制器呢，因为这里的代码可以控制那些数据，并且可以和页面上的内容双向绑定。这样我们要得到页面上的数据就不用再通过获取结点，在获取内容的方式了，可以直接获取内存中的数据，也可以直接修改内存中的数据修改页面显示。比如上述代码就是通过修改内存中的name来修改页面中的name，所以打开<code>localhost:8080/</code>可以看到input输入框里面已经有一个123了。至于controller里面的$scope是啥？emmmmmm…继续简单理解下就是包含页面所有数据的一个对象，页面的所有变量的双向绑定的值都在这个$scope里面。</p>
<p>一句话总结controller：控制页面的数据。另外，页面的数据全部在$scope里面，$scope里面的东西在页面上也可以直接用。</p>
<p>为了加深理解，我们加个按钮显示数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;appCtrl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;双向绑定测试&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span>&#123;&#123;name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">ng-click</span>=<span class="string">&quot;show()&quot;</span>&gt;</span>show<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope</span>) &#123;</span><br><span class="line">        $scope.<span class="property">name</span> = <span class="number">123</span>;</span><br><span class="line">        $scope.<span class="property">show</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>($scope.<span class="property">name</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>可以看到，在html里面我们在input下面加了一个button，并在标签里面加上了<code>ng-click=&quot;show()&quot;</code>这个ng-click就是angular的事件绑定的写法，至于这个show()自然就是绑定在click时间的函数啦，show这个函数在controller里面就是$scope.show，之前说了，页面的所有内容都是在$scope下的。然后我们在controller里面给它赋值了一个函数，函数log出<code>$scope.name</code>，现在打开控制台，点击按钮，就能看到控制台输出了123，我们修改input的内容，再按一下按钮，会发现控制台输出了我们填写的内容，这就是双向绑定的直观概念，它的好处也就显而易见了，对于表单啊什么的直接绑定到$scope里面了，点击按钮就可以发送请求给后端了，不用麻烦的一个个获取。</p>
<p>我们试试看吧</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;appCtrl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;user.name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;user.pwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">ng-click</span>=<span class="string">&quot;submit()&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope</span>) &#123;</span><br><span class="line">        $scope.<span class="property">submit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>($scope.<span class="property">user</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>我们修改了设置了controller的那个div里面的内容，加了两个input用于输入用户名和密码，ng-mode我们绑定到了user的两个属性，button的click绑到了submit函数。注意，我们ng-model不是name和pwd，而是user.name和user.pwd，这样controller里面直接<code>$scope.user</code>就是包含了两个属性的对象，非常方便。在另外，页面的数据会自动存放在controller里面，我们不用在controller里面重新定义一遍就可以直接用（比如这里就是<code>console.log($scope.user);</code>我们在外面并没有也不需要定义$scope.user）现在看看效果。打开<code>http://localhost:8080</code>随便输入什么，点击提交，就可以看到控制台输出了user对象。当然我们也可以初始化一下，设置默认值，这个在调试阶段特别好用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope</span>) &#123;</span><br><span class="line">        $scope.<span class="property">user</span> = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="number">123</span>,</span><br><span class="line">            <span class="attr">pwd</span>: <span class="number">123</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $scope.<span class="property">submit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>($scope.<span class="property">user</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>刷新一下浏览器，可以看到两个输入框已经有内容了，在调试时就不用反复输入了。</p>
<p>好了，我们已经可以在控制台看到数据打印出来了，那么怎么发送到后端呢？这里就要用ajax了，ajax就是一个发送异步请求的东西而已，具体不详细讲，只说怎么用（具体内容可看我写的有关angular的内容，有空写的话。。。）在angular里面，提供了一个$http的服务用语发送请求。$http和$scope一样，都是一个angular提供的服务，需要作为controller的参数才能使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope, $http</span>) &#123;</span><br><span class="line">        $scope.<span class="property">user</span> = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="number">123</span>,</span><br><span class="line">            <span class="attr">pwd</span>: <span class="number">123</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $scope.<span class="property">submit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>($scope.<span class="property">user</span>);</span><br><span class="line">            $http.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/user/login&#x27;</span>,$scope.<span class="property">user</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>首先可以看到我们在controller的参数里面加入了$http,然后可以看到在submit函数里面加了一行<code>$http.post(&#39;http://localhost:8080/user/login&#39;,$scope.user);</code>。这一行表示向localhost:8080&#x2F;user&#x2F;login这个路径发送了一个post请求，请求的参数是$scope.user。好了，我们要在这里插入一点后端的内容。前端已经吧输入发过去了，后端怎么获取呢？还记得之前后端的router.get么，它接受get请求，事实上我们在浏览器上输入一个url就是一个get请求。现在要一个post，那么我们就加上对post的处理。<br>修改根目录的routes文件夹下的user.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// routes/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>,<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;login&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>这里我们先输出一个login字符串来看看是不是请求到了这个接口（所谓的接口就是一个uri，比如这里就是<code>http://localhost:8080/user/login</code>）。点击submit，然后打开运行着npm start的那个命令行，可以看到在黑框框下输出了一个字符串“login”，说明我们成功请求到这个接口了，那么问题就来了，我们怎么获取到传过来的参数呢？express有很好的中间件机制，当然是使用别人提供的中间件啦！这里我们用body-parser这个中间件，它可以预先帮我解析请求中的请求体，并把post请求的参数设置到req.body里面。首先要安装，在命令行多按几次ctrl+c终止那个那个npm start的命令，然后执行<code>npm i --save body-parser</code>，安装完后去修改根目录下的app.js，吧依赖引入进来，并用app.use把body-parser配置好</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// 引入path</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="comment">// 实例化express</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="comment">// 引入body-parser</span></span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入别的路由模块</span></span><br><span class="line"><span class="keyword">const</span> index = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">&#x27;./routes/user&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> timetable = <span class="built_in">require</span>(<span class="string">&#x27;./routes/timetable&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析json格式的post请求体，给req添加body属性</span></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">json</span>());</span><br><span class="line"><span class="comment">// 中间件只解析urlencoded 请求体，并返回，只支持UTF-8编号文本</span></span><br><span class="line"><span class="comment">// extend</span></span><br><span class="line"><span class="comment">// ture-&gt;使用queryString库（默认） false-&gt;使用qs库。</span></span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置静态资源路径，express自动处理get请求</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;public&#x27;</span>)));</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, index);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/user&#x27;</span>, user);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/timetable&#x27;</span>, timetable);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;404 NOT FOUND！&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = app;</span><br></pre></td></tr></table></figure>

<p>其实我们就加了这3行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">json</span>());</span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br></pre></td></tr></table></figure>

<p>第一行引入依赖没啥问题，后两行用app.use说明所有的请求都会经过他们，和设置静态页面一样的用法。至于后两行use里面啥意思，上面的文件也做了详细说明，这里，具体可以自行搜索相关资料进一步学习，这里我们暂时就知道怎么用就好了。<br>然后我们的req.body里面应该已经有内容了。修改routes&#x2F;user.js，把之前的login字符串改为req.body</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>,<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>好，继续运行npm start，打开浏览器按submit。在打开命令行的时候我们可以看到输出的不是login了，而是<code>&#123; name: 123, pwd: 123 &#125;</code>这个对象，前端已经成功到后端了，那么后端怎么发送信息给前端呢？超简单res.send啊！不不不，我们的意思是，前端怎么收到呢？angular的$http早就帮我们搞定了这些。<br>routes&#x2F;user.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>,<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;登陆成功!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>public&#x2F;js&#x2F;index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope, $http</span>) &#123;</span><br><span class="line">        $scope.<span class="property">user</span> = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="number">123</span>,</span><br><span class="line">            <span class="attr">pwd</span>: <span class="number">123</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $scope.<span class="property">submit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>($scope.<span class="property">user</span>);</span><br><span class="line">            $http.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/user/login&#x27;</span>,$scope.<span class="property">user</span>)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>后端部分就是加了一个res.send发送了一个字符串，前端部分可以看到我们在刚刚那个post下加了一个then，这里$http.post返回了一个promise，具体promise是啥可以百度也可以看我别的文章（哇，我都挖了几个坑了。。。慢慢填。。。）then接受两个参数，都是函数，第一个函数是返回成功时的情况，第二个函数就是返回错误是的情况。我们暂时先不考虑错误情况，直接then接受一个函数，然后把res作为参数并打印出来，可以看到控制台输出了好多东西。嘛。。。其实也就是一个对象啦，我们关注data这个字段就好了，可以看到data这个字段里面的东西就是后端返回的值。<br>装个逼用一下es6的解构赋值（也不算啥新东西啦，es8都要出来了。。。）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$http.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/user/login&#x27;</span>,$scope.<span class="property">user</span>)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">res</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<p>改为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$http.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/user/login&#x27;</span>, $scope.<span class="property">user</span>)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">&#123;data&#125;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">                &#125;)</span><br></pre></td></tr></table></figure>

<p>再刷新浏览器点击提交，就可以看到控制台输出后端返回的字符串啦，是不是很简单~</p>
<p>随着逻辑越来越复杂，在controller里面既要控制页面的数据，又要和后端交互处理请求相应，那代码就会越来越庞大，是事实再分离一波了！这时候就可以手写service了。service字面意思就是服务，就是提供一些通用的服务供controller调用，其实之前用到的$scope,$http都是服务，只不过它们是angular提供的服务，我们也可以自己定义服务。比如定义一个UserService服务，把和用户相关的比如登录注册重置密码的逻辑都放在这里供controller调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public/js/index.js</span></span><br><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope, UserService</span>) &#123;</span><br><span class="line">        $scope.<span class="property">user</span> = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="number">123</span>,</span><br><span class="line">            <span class="attr">pwd</span>: <span class="number">123</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $scope.<span class="property">submit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>($scope.<span class="property">user</span>);</span><br><span class="line">            <span class="title class_">UserService</span>.<span class="title function_">login</span>($scope.<span class="property">user</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">service</span>(<span class="string">&#x27;UserService&#x27;</span>, <span class="keyword">function</span> (<span class="params">$http</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">login</span> = <span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">            $http.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/user/login&#x27;</span>, user)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">&#123;data&#125;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>这样虽然controller和service分开了，但是都放在一个文件还是觉得很乱，那我们进一步分离，首先删了public&#x2F;js&#x2F;index.js。因为我们要把它拆开。<br>在public文件夹下新建app.js作为主要入口，然后在public&#x2F;js下新建controller.js和service.js<br>public&#x2F;app.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [</span><br><span class="line">    <span class="string">&#x27;app.controller&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;app.service&#x27;</span></span><br><span class="line">])</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>public&#x2F;js&#x2F;controller.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app.controller&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope, UserService</span>) &#123;</span><br><span class="line">        $scope.<span class="property">user</span> = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="number">123</span>,</span><br><span class="line">            <span class="attr">pwd</span>: <span class="number">123</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $scope.<span class="property">submit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>($scope.<span class="property">user</span>);</span><br><span class="line">            <span class="title class_">UserService</span>.<span class="title function_">login</span>($scope.<span class="property">user</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>public&#x2F;js&#x2F;service.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app.service&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">service</span>(<span class="string">&#x27;UserService&#x27;</span>, <span class="keyword">function</span> (<span class="params">$http</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">login</span> = <span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">            $http.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/user/login&#x27;</span>, user)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">&#123;data&#125;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>好了，分完了，就是把controller，service简单拆了一下，另外controller.js第一行的module名字取为“app.controller”，service的module名字取为“app.service”。然后在app.js里面的module的第二个参数去进行“依赖注入”，就是把module名字放进数组里就好啦。<br>最后还有一步！把这些js引入到html里面（把index的引入删除在加上新加的三个文件的引入）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/angular.js/1.6.6/angular.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/controller.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/service.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;app.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>好了运行<code>http://localhost:8080</code>看看效果吧（应该没什么效果，和原来一样的界面）</p>
<h2 id="webpack的加入"><a href="#webpack的加入" class="headerlink" title="webpack的加入"></a>webpack的加入</h2><p>可以看到，之前我们只是简单做了个代码分离，就要在index.html多加入三个script标签，以后万一要加上别的库文件又是一大堆script标签，然后要加上css的话继续一堆link。。。另外，每次写完代码都要刷新一遍网页也很烦，后端部分我们已经用supervisor自动重启服务器来减轻负担了，前端有没有自动刷新浏览器什么的工具啊？必须是有的，而且可以一起吧上面两个问题全部解决！</p>
<p>webpack就是这么一个工具，它会从一个（或多个）js文件开始，一次查找所有的依赖，并引入进来打包成一个js文件。它强大的加载器以及插件可以做到找到css依赖甚至编译less，scss，ts等语言并引入。还有一个叫做webpack-dev-server的东西可以实现热加载（就是自动刷新浏览器，甚至不刷新浏览器就可以修改页面）。它的工作全部都写入一个配置文件，并根据配置文件的内容，实现一定功能，比如最基础的查找js依赖，配置完加载器后可以加载css文件，编译less，scss，配置devServer后可以热更新，配置html插件后可以吧标签自动插入到html文件里面。</p>
<p>听得那么多都心动了吧？那我们开始吧！</p>
<p>既然要用webpack，当然得先安装（下载）喽，就是一句npm i的事，但是我们要装的不只是webpack，还有一些别的东西（因为webpack要加载html等需要别的配置，所以需要相关加载器或者插件等）这里我们就一次性下完啦。。。<br><code>npm i --save-dev webpack webpack-dev-server html-webpack-plugin open-browser-webpack-plugin</code><br><code>npm i --save-dev babel babel-core babel-loader babel-plugin-istanbul babel-preset-es2015</code><br><code>npm i --save-dev css-loader less-loader postcss-loader sass-loader style-loader</code><br><code>npm i --save-dev file-loader html-loader istanbul-instrumenter-loader url-loader</code><br>为了美观点我这里分成了4条，当然也可以写到一句里面。。第一条是webpack和热加载的服务器webpack-dev-server，后面两个是webpack的两个插件，第一个用于自动在html里面插入标签（当然它有更牛逼的功能，这里我们就用来插入标签了，就是打包后的script标签就是靠它加入到html文件的）第二个是自动打开浏览器的插件。第二条是js相关的编译加载器，第三条是css相关，最后一条是别的杂七杂八的加载器。。。因为webpack本身只是处理js中的模块依赖问题的，有了这些加载器后可以加载别的css等文件（还可以编译es6，编译less等）</p>
<p>好了装完后怎么让它们合作起来呢？根目录下新建一个webpack.config.js的文件（这是webpack的默认配置文件名，要是换别的名字需要在启动webpack时指定。用这个名就不用另外指定了）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OpenBrowserPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;open-browser-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一些路径</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">APP_PATH</span> = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;public/app.js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BUILD_PATH</span> = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;build&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 入口，分为app 入口和提取插件库的入口</span></span><br><span class="line">    <span class="attr">entry</span>: &#123;</span><br><span class="line">        <span class="attr">app</span>: <span class="variable constant_">APP_PATH</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出文件路径和名字</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="variable constant_">BUILD_PATH</span>,</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&#x27;./public/index.html&#x27;</span>,</span><br><span class="line">            <span class="attr">inject</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">            <span class="attr">minify</span>: <span class="literal">false</span></span><br><span class="line">        &#125;),</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自动启动浏览器</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">OpenBrowserPlugin</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;http://localhost:8081&#x27;</span>&#125;)</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dev 服务器</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">inline</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">progress</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">contentBase</span>: <span class="string">&quot;./build&quot;</span>, <span class="comment">// dev server的根路径</span></span><br><span class="line">        <span class="attr">port</span>: <span class="number">8081</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载器</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="string">&quot;loaders&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.html$/</span>,</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&#x27;style-loader!css-loader&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.less/</span>,</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&#x27;style-loader!css-loader!less-loader&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.(png)|(jpg)|(gif)|(woff)|(svg)|(eot)|(ttf)$/</span>,</span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">loader</span>: <span class="string">&quot;url-loader&quot;</span>,</span><br><span class="line">                        <span class="attr">options</span>: &#123;</span><br><span class="line">                            <span class="attr">limit</span>: <span class="number">50000</span>,   <span class="comment">//小于50K的 都打包</span></span><br><span class="line">                            <span class="attr">name</span>: <span class="string">&quot;[hash:8].[name].[ext]&quot;</span>,</span><br><span class="line">                            <span class="attr">publicPath</span>: <span class="string">&quot;img/&quot;</span>,  <span class="comment">//替换CSS引用的图片路径 可以替换成爱拍云上的路径</span></span><br><span class="line">                            <span class="attr">outputPath</span>: <span class="string">&quot;../img/&quot;</span>        <span class="comment">//生成之后存放的路径</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">                <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                <span class="attr">include</span>: <span class="variable constant_">APP_PATH</span>,</span><br><span class="line">                <span class="attr">query</span>: &#123;</span><br><span class="line">                    <span class="attr">presets</span>: [<span class="string">&#x27;es2015&#x27;</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&#x27;source-map&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我知道被甩一脸代码你的内心是拒绝的，emmm…毕竟webpack有很多东西，详细信息需要参考官网文档，这里只给出了一些简单的配置例子而已（我也掌握的不多，仅仅是能用的程度ORZ…）之前已经提到了webpack是依赖处理工具，所以开头配置就是entry字段，entry表示依赖的起点，表示js的根文件，也是它查找依赖的起点。然后有entry就有output，这就是编译完后的代码存放的位置，另外webpack通过插件和模块加载器来扩展功能，比如我们加了HtmlWebpackPlugin插件配置，就表示吧生成的代码作为资源引用插入到对应html的body标签，OpenBrowserPlugin插件就表示以默认浏览器自动打开对应url。关于这些插件的用法每个都有相关的官方文档可供参考，这些不是webpack自带的，需要开发者自行查找相关插件（一般你遇到的诡异的需求都有别人给你做好的插件可以用）。devServer字段就是配置webpack-dev-server的地方，后面的module就是模块的加载器了，比如webpack不认识html文件就需要用HTML加载器引入。这里就是简单提一下webpack算是抛砖引玉，要深入学习还是要去啃webpack官方文档啊~另外这里就是单纯的够用，比如现在babel有些更新也没怎么关注…一切使用以官方文档为准。</p>
<p>好了，配置文件都写完了是不是迫不及待要试一下？别急，有些地方也得改一改。首先当然是html文件删除所有的script，link标签。<br>public&#x2F;index.html就只剩下下面这坨光秃秃的代码了，看上去清爽了一点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>timetable<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ng-app</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Time Table<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;appCtrl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;user.name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;user.pwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">ng-click</span>=<span class="string">&quot;submit()&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>至于我们删除部分的代码之前webpack配置的插件会吧打包后的代码自动引入的~<br>下一步改造js，既然app.js定义了app模块和界面绑定，它显然就是起点啦</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// public/app.js</span></span><br><span class="line"><span class="keyword">import</span> angular <span class="keyword">from</span> <span class="string">&#x27;angular&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> controller <span class="keyword">from</span> <span class="string">&#x27;./js/controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> service <span class="keyword">from</span> <span class="string">&#x27;./js/service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">angular.<span class="title function_">module</span>(<span class="string">&#x27;app&#x27;</span>, [</span><br><span class="line">    controller,</span><br><span class="line">    service</span><br><span class="line">])</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./css/index.css&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>emmmmm….似乎我们把angular的scrip也删了，然后还忘记装了？那装一下吧。。。<code>npm i --save angular</code>。然后可以看到我们原来直接写在数组里的是字符串，现在是引入的内容。至于这个import只是一个es6的模块语法，表示从对应的文件引入某个变量或者函数。既然引入了，那对应的文件是不是要导出？没错，继续改造controller和service文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public/js/controller.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> angular.<span class="title function_">module</span>(<span class="string">&#x27;app.controller&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope, UserService</span>) &#123;</span><br><span class="line">        $scope.<span class="property">user</span> = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="number">123</span>,</span><br><span class="line">            <span class="attr">pwd</span>: <span class="number">123</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $scope.<span class="property">submit</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>($scope.<span class="property">user</span>);</span><br><span class="line">            <span class="title class_">UserService</span>.<span class="title function_">login</span>($scope.<span class="property">user</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="property">name</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public/js/service.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> angular.<span class="title function_">module</span>(<span class="string">&#x27;app.service&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">service</span>(<span class="string">&#x27;UserService&#x27;</span>, <span class="keyword">function</span> (<span class="params">$http</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">login</span> = <span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">            $http.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/user/login&#x27;</span>, user)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">&#123;data&#125;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="property">name</span>;</span><br></pre></td></tr></table></figure>

<p>controller和service的修改完全一样就是加个导出而已，至于controller和service用到的angular，已经在app导入过了，你想再导入一遍也没啥问题，因为webpack会判断发现已经有了就不会重复导入。导出的语法就是一个export，至于default，就是默认导出，这个每个文件只能有一个，别人导入的时候就可以不用管有什么无脑导入就行了。至于更多的es6模块部分的内容建议阅读相关博客深入了解。<strong>（敲黑板！！es6是必修课！！）</strong><br>最后一步，启动命令行！当然先加个别名，可以少打点东西也好记，怎么加之前已经提过了，就是在package.json的scripts字段加一条<br><code>&quot;dev&quot;: &quot;webpack-dev-server --history-api-fallback --hot --inline --progress --content-base ./build/ --port 8081&quot;</code><br>因为之前装了好多依赖，所以现在package.json文件是这样的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;timetable&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;supervisor bin/www&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack-dev-server --history-api-fallback --hot --inline --progress --content-base ./build/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;angular&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.6.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;body-parser&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.18.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;express&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.16.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;babel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.23.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babel-core&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.26.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.1.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babel-plugin-istanbul&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.1.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;babel-preset-es2015&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.24.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;css-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.28.7&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;file-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.1.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;html-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.5.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;html-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.30.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;istanbul-instrumenter-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;less-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.0.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;open-browser-webpack-plugin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;postcss-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.8&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sass-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^6.0.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;style-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.19.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;supervisor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.12.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url-loader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.6.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.8.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.9.4&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>恩，终于结束了。。。转换的过程是痛苦的，结果是美好的，现在打开命令行进入项目根目录输入<code>npm run dev</code>，可以看到浏览器自动打开了，界面什么的和之前一样，我们可以随便修改点css代码看看效果，比如把颜色改为蓝色，然后回到浏览器就可以看到自动更新了。然而当我们点击提交却出错了，他说我们跨域了。跨域是因为webpack-dev-server自己开了一个服务器在8081端口，我们额后端是8080端口，所以就被拒绝了，我们只要在后端加几行就好了。<br>打开根目录下的app.js文件，在这几行的<strong>上面</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, index);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/user&#x27;</span>, user);</span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/timetable&#x27;</span>, timetable);</span><br></pre></td></tr></table></figure>

<p>加上这几行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app访问预处理中间件</span></span><br><span class="line"><span class="comment">// 设置跨域请求许可以及返回内容的数据格式</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>); <span class="comment">//允许哪些url可以跨域请求到本域</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET,POST&quot;</span>); <span class="comment">//允许的请求方法，一般是GET,POST,PUT,DELETE,OPTIONS</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;x-requested-with,content-type,Token&quot;</span>); <span class="comment">//允许哪些请求头可以跨域</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后在点击提交试试，应该就好了，这是nodejs常用的解决跨域的方式。</p>
<hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h2><p>前后端都连上了，该到数据库了。前端发过来的用户名和密码，我们需要存到数据库，一个注册的功能通常都是这样，前端发送用户输入的数据到后端，后端存入数据库中，这样下次这个用户只需要登录就好，并且与他相关的数据也会保存在一块。</p>
<p>常用的数据库是关系数据库，常见的Oracle，SQL Server还有MySQL等都是关系数据库。但是面对互联网日益爆增的数据量，关系数据库逐渐显得力不从心，于是出现了一类新型的数据库。我们称为NoSQL，Not Only SQL。非关系型数据库。非关系数据库又有好多种，MongoDB属于其中的文档型数据库。它的优点是数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构（这句来自百度百科）。而且存储结构就是json的结构，非常适合与js协作。</p>
<p>MongoDB的安装不多说了就是一个数据库引擎而已。主要是启动会有点东西需要配置。而每次手动启动也很烦一般就把它设置为一个服务了然后开机自启就行。这里引用菜鸟教程的<a href="http://www.runoob.com/mongodb/mongodb-window-install.html">配置方式</a></p>
<blockquote>
<p>管理员模式打开命令行窗口<br>创建目录，执行下面的语句来创建数据库和日志文件的目录<br>mkdir c:\data\db<br>mkdir c:\data\log<br>创建配置文件<br>创建一个配置文件。该文件必须设置 systemLog.path 参数，包括一些附加的配置选项更好。<br>例如，创建一个配置文件位于 C:\mongodb\mongod.cfg，其中指定 systemLog.path 和 storage.dbPath。具体配置内容如下：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">    destination: file</span><br><span class="line">    path: c:\data\log\mongod.log</span><br><span class="line">storage:</span><br><span class="line">    dbPath: c:\data\db</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过执行mongod.exe，使用–install选项来安装服务，使用–config选项来指定之前创建的配置文件。<br>“C:\mongodb\bin\mongod.exe” –config “C:\mongodb\mongod.cfg” –install<br>启动MongoDB服务<br>net start MongoDB<br>关闭MongoDB服务<br>net stop MongoDB<br>移除MongoDB服务<br>“C:\mongodb\bin\mongod.exe” –remove</p>
</blockquote>
<p>闲每次开启服务麻烦可以去windows的“服务”里设置开机自启动</p>
<h2 id="MongoDB可视化工具"><a href="#MongoDB可视化工具" class="headerlink" title="MongoDB可视化工具"></a>MongoDB可视化工具</h2><p>所谓可视化工具也可以称为数据库管理工具，就是可以直接在界面上以用户友好的方式查看数据库的内容。MongoDB的话我常用的是mongobooster和Robomongo，mongobooster支持数据库的json文件导入导出，但是界面上个人认为Robomongo更友好一点，所以我一般做简单的查询修改都是用Robomongo。至于这两个软件就自行寻找安装包安装啦，就是两个普通软件而已…mongobooster是收费的，不过免费部分的功能也够用了（反正我只是用来导入导出数据。。。）</p>
<p>Robmongo打开后要创建连接，链接本地的数据库服务后才可以操作里面的内容，点击create，保持默认点击save就好了，你愿意的话save之前改一下name啥的也行，（我改成了localhost。。）另外MongoDB默认是没有密码的，所以安全方面要另外设置，这里只是入门就保持默认了，做项目要用MongoDB一定要设置密码哦。然后连上后里面只有system和test，这是默认的数据库别理它。。</p>
<h2 id="mongoose库介绍"><a href="#mongoose库介绍" class="headerlink" title="mongoose库介绍"></a>mongoose库介绍</h2><p>前面配置了数据库和可视化软件，现在就要正式码代码啦。道理我都懂，所以我要怎么用js来操作数据库呢？emmmmm，在后端程序和数据库引擎之前我们需要一个桥梁，这就是数据库驱动，所以我们需要安装一个库来帮我们，这里我选的是mongoose这个库。执行<code>npm i --save mongoose</code>安装mongoose库。装完后我们需要创建一个链接，连上后就可以用js代码操作数据库了。链接很简单，无非就是端口号啊数据库名啊账号密码啊之类的对上就好了，因为默认没有账号密码所以就需要端口号和数据库名，这里我们选择time_table作为名字。然后我们总不能操作一次重新写一段连接数据库的代码吧？所以根目录下新建一个config文件夹里面新建config.js，写上以下内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//config/config.js</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;mongoose&#x27;</span>);</span><br><span class="line">mongoose.<span class="title function_">connect</span>(<span class="string">&#x27;mongodb://localhost:27017/time_table&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = mongoose.<span class="property">connection</span>;</span><br><span class="line">db.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">console</span>.<span class="property">error</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>, <span class="string">&#x27;connection error:&#x27;</span>));</span><br><span class="line">db.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="variable language_">console</span>, <span class="string">&#x27;connection success:&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">mongoose</span> = mongoose;</span><br></pre></td></tr></table></figure>

<p>这些代码均可以从mongoose的<a href="http://mongoosejs.com/docs/index.html">文档</a>里找到，代码很简单，导入mongoose库后创建一个链接然后导出mongoose。我们之前不是说后端已经拿到数据了么，在routes&#x2F;user.js里。我们只是简单的输出了一下前端的数据，现在我们要真正把它保存到数据库里面。以下的代码也从文档中可以找到。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//routes/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入已经配置好数据库连接的mongoose库</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;../config/config&#x27;</span>).<span class="property">mongoose</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义User这个&quot;表&quot;，noSQL术语叫做集合(collection)，调用mongoose.model并传入第一个参数是表名，第二个是表的结构</span></span><br><span class="line"><span class="comment">//其中第二个参数作为表的结构使用mongoose.Schema定义，具体内容官网都有详细的文档。</span></span><br><span class="line"><span class="keyword">const</span> userSchema = mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">pwd</span>: <span class="title class_">String</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;User&#x27;</span>, userSchema);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>,<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    <span class="comment">//根据定义的model新建一个对象并保存，第二个参数是保存成功后的回调函数</span></span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(req.<span class="property">body</span>);</span><br><span class="line">    user.<span class="title function_">save</span>(<span class="keyword">function</span> (<span class="params">err, user</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(user);</span><br><span class="line">        res.<span class="title function_">send</span>(<span class="string">&#x27;登陆成功!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>可以看到我们对routes&#x2F;user.js做了点手脚，首先导入配置好的mongoose库，然后新建了一个User的结构，另外提一句，mongoose.model第一个参数的复数形式才是真正的表名。前端数据发过来后我们用发过来的数据new了一个user并保存了。现在去页面上点击提交可以看到命令行里面输出了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">name</span>: <span class="number">123</span>, <span class="attr">pwd</span>: <span class="number">123</span> &#125;</span><br><span class="line">&#123; <span class="attr">name</span>: <span class="string">&#x27;123&#x27;</span>, <span class="attr">pwd</span>: <span class="string">&#x27;123&#x27;</span>, <span class="attr">_id</span>: 5a8d7d85148af21d2ca5baa7, <span class="attr">__v</span>: <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>第一个自然就是前端传过来的数据，第二个就是保存的数据，MongoDB自动生成了<code>_id</code>和<code>_v</code>两个字段<code>_id</code>自然是唯一的值用于区分每个对象，这个值大家应该都不一样，至于这个值怎么产生的可以参考<a href="http://blog.csdn.net/after_you/article/details/66971680">这个</a>，总之你知道<code>_id</code>可以用于唯一区分数据库里一条数据就好了。<code>_v</code>是版本号，具体用法可以看<a href="http://mongoosejs.com/docs/guide.html#versionKey">官方文档</a>。然后我们打开Robmongo可以看到里面多了”time_table”这个，如果没有的话右键连接名（就是侧栏最上面那个，名字取决于你创建时的名字，我的是localhost，默认是New Connection）找到第二个Refresh，刷新完就有了。然后可以看到下面有Collections，Functions，Users。展开Collections，可以看到users，双击就能看到里面的数据了，可以看到这样的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="title class_">ObjectId</span>(<span class="string">&quot;5a8d7a29f54eab2accaca062&quot;</span>),</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span> : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;__v&quot;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去网页上多点几下提交再打开Robmongo就变成这样了（没变化的话按f5刷新）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="title class_">ObjectId</span>(<span class="string">&quot;5a8d7a29f54eab2accaca062&quot;</span>),</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span> : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;__v&quot;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="title class_">ObjectId</span>(<span class="string">&quot;5a8d7d85148af21d2ca5baa7&quot;</span>),</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span> : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;__v&quot;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : <span class="title class_">ObjectId</span>(<span class="string">&quot;5a8d840e148af21d2ca5baa8&quot;</span>),</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span> : <span class="string">&quot;123&quot;</span>,</span><br><span class="line">    <span class="string">&quot;__v&quot;</span> : <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到我们每次点一下提交就执行了一次保存，又因为主键id是自动生成的所以name和pwd重复它也会保存，如果我们要让name不能重复，那这些逻辑都需要自己代码实现，比如先查询一下数据库看看name有没有被占用，没有的话就保存，有的话就返回一个错误信息。我们可以对login接口做如下修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;<span class="string">&#x27;name&#x27;</span>: req.<span class="property">body</span>.<span class="property">name</span>&#125;, <span class="keyword">function</span> (<span class="params">err, user</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;数据库错误&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user) &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;用户已存在&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//根据定义的model新建一个对象并保存，第二个参数是保存成功后的回调函数</span></span><br><span class="line">            <span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(req.<span class="property">body</span>);</span><br><span class="line">            user.<span class="title function_">save</span>(<span class="keyword">function</span> (<span class="params">err, user</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(user);</span><br><span class="line">                res.<span class="title function_">send</span>(<span class="string">&#x27;登陆成功!&#x27;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>User.findOne就是去users这个collection里面查找一个，找到或者没找到都会返回，找到了后回调函数的第二个参数就是user。没找到第二个参数就是null。所以如果user不是null就返回用户已存在，否者就保存。可以去网页上试验一下，点击提交可以看到控制台输出了用户已存在，把name改成1234再点提交就输出登录成功了。emmm…仔细想想这怎么会是登录呢，这明明应该是注册的逻辑嘛<del>那我们就做简单的修改，把它变成register就好了</del>上面的<code>/login</code>改成<code>/register</code>，在新建一个login的逻辑。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="title class_">User</span>.<span class="title function_">findOne</span>(req.<span class="property">body</span>, <span class="keyword">function</span> (<span class="params">err, user</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;数据库错误&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user) &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;登陆成功!&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;账号或密码错误!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;<span class="string">&#x27;name&#x27;</span>: req.<span class="property">body</span>.<span class="property">name</span>&#125;, <span class="keyword">function</span> (<span class="params">err, user</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;数据库错误&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user) &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;用户已存在&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//根据定义的model新建一个对象并保存，第二个参数是保存成功后的回调函数</span></span><br><span class="line">            <span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(req.<span class="property">body</span>);</span><br><span class="line">            user.<span class="title function_">save</span>(<span class="keyword">function</span> (<span class="params">err, user</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(user);</span><br><span class="line">                res.<span class="title function_">send</span>(<span class="string">&#x27;登陆成功!&#x27;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样才像样嘛，注册才需要写入数据库，登录只要判断有没有这儿数据就行了，有就说登陆成功没有就说账号或者密码错误。关注login接口的这一行<code>User.findOne(req.body, function (err, user) &#123;...&#125;)</code>第一个参数直接就是req.body。因为我们定义的数据结构和前端传过来的一样所以就这么写，完整的写法是这样的：<code>User.findOne(&#123;name:req.body.name, pwd:req.body.pwd&#125;, function (err, user) &#123;...&#125;)</code>（在这里也是多此一举的写法。。。）。findOne的第一个参数就是查找条件，只有完全满足才行。api文档看<a href="http://mongoosejs.com/docs/api.html#findone_findOne">这里</a></p>
<p>改完后端那顺便前端也改了呗~<br>public&#x2F;index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">&quot;appCtrl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;user.name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">ng-model</span>=<span class="string">&quot;user.pwd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">ng-click</span>=<span class="string">&quot;login()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">ng-click</span>=<span class="string">&quot;register()&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public/js/controller.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> angular.<span class="title function_">module</span>(<span class="string">&#x27;app.controller&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">controller</span>(<span class="string">&#x27;appCtrl&#x27;</span>, <span class="keyword">function</span> (<span class="params">$scope, UserService</span>) &#123;</span><br><span class="line">        $scope.<span class="property">user</span> = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="number">123</span>,</span><br><span class="line">            <span class="attr">pwd</span>: <span class="number">123</span></span><br><span class="line">        &#125;;</span><br><span class="line">        $scope.<span class="property">login</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title class_">UserService</span>.<span class="title function_">login</span>($scope.<span class="property">user</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        $scope.<span class="property">register</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title class_">UserService</span>.<span class="title function_">register</span>($scope.<span class="property">user</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="property">name</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public/js/service.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> angular.<span class="title function_">module</span>(<span class="string">&#x27;app.service&#x27;</span>, [])</span><br><span class="line">    .<span class="title function_">service</span>(<span class="string">&#x27;UserService&#x27;</span>, <span class="keyword">function</span> (<span class="params">$http</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">login</span> = <span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">            $http.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/user/login&#x27;</span>, user)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">&#123;data&#125;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">register</span> = <span class="keyword">function</span> (<span class="params">user</span>) &#123;</span><br><span class="line">            $http.<span class="title function_">post</span>(<span class="string">&#x27;http://localhost:8080/user/register&#x27;</span>, user)</span><br><span class="line">                .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">&#123;data&#125;</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="property">name</span>;</span><br></pre></td></tr></table></figure>

<p>改动很简单，就是原来提交的按钮改成了两个按钮，一个登陆一个注册。对应的controller，service也改成了登录，注册的逻辑。当然，真实应用的注册应该不止这两个字段，登录和注册的内容应该也是不一样的。这里就一切从简了。</p>
<p>细心的童鞋应该发现了，routes&#x2F;user.js里面除了一个登陆一个注册还有一些诡异的代码，就是定义数据结构啊之类的。如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入已经连接好数据库的mongoose库</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;../config/config&#x27;</span>).<span class="property">mongoose</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义User这个&quot;表&quot;，noSQL术语叫做集合(collection)，调用mongoose.model并传入第一个参数是表名，第二个是表的结构</span></span><br><span class="line"><span class="comment">//其中第二个参数作为表的结构使用mongoose.Schema定义，具体内容官网都有详细的文档。</span></span><br><span class="line"><span class="keyword">const</span> userSchema = mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">pwd</span>: <span class="title class_">String</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;User&#x27;</span>, userSchema);</span><br></pre></td></tr></table></figure>

<p>这些代码定义了users集合的数据结构，并且User这个模型(model)也是和数据库直接绑定的，就是说我们要通过这个User来操纵users这个集合。所以别的地方要用users里面的数据就要获取到User的实例，那么我们就要吧User导出，但是这样是不合理的，因为这个文件只是一个路由，User相关的定义应该放到别的地方统一定义。所以在根目录下新建model文件夹，并新建User.js吧模型定义的相关代码移出去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//model/User.js</span></span><br><span class="line"><span class="comment">//导入已经连接好数据库的mongoose库</span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&#x27;../config/config&#x27;</span>).<span class="property">mongoose</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义User这个&quot;表&quot;，noSQL术语叫做集合(collection)，调用mongoose.model并传入第一个参数是model名，第二个是表的结构</span></span><br><span class="line"><span class="comment">//其中第二个参数作为表的结构使用mongoose.Schema定义，具体内容官网都有详细的文档。（比如数据类型之类的）</span></span><br><span class="line"><span class="comment">//第三个参数是集合名，省略的话默认会使用第一个参数的全小写的复数形式（所以这个例子写不写都一样）</span></span><br><span class="line"><span class="keyword">const</span> userSchema = mongoose.<span class="title class_">Schema</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">String</span>,</span><br><span class="line">    <span class="attr">pwd</span>: <span class="title class_">String</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = mongoose.<span class="title function_">model</span>(<span class="string">&#x27;User&#x27;</span>, userSchema, <span class="string">&#x27;users&#x27;</span>);</span><br><span class="line"><span class="comment">// const User = mongoose.model(&#x27;User&#x27;, userSchema); 和上面一行效果一样</span></span><br><span class="line"><span class="comment">// const User = mongoose.model(&#x27;User&#x27;, userSchema, &#x27;user&#x27;); 这么写集合名就是user了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">User</span> = <span class="title class_">User</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//routes/user.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = <span class="built_in">require</span>(<span class="string">&#x27;../model/User&#x27;</span>).<span class="property">User</span>;</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="title class_">User</span>.<span class="title function_">findOne</span>(req.<span class="property">body</span>, <span class="keyword">function</span> (<span class="params">err, user</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;数据库错误&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user) &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;登陆成功!&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;账号或密码错误!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    <span class="title class_">User</span>.<span class="title function_">findOne</span>(&#123;<span class="string">&#x27;name&#x27;</span>: req.<span class="property">body</span>.<span class="property">name</span>&#125;, <span class="keyword">function</span> (<span class="params">err, user</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;数据库错误&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user) &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(<span class="string">&#x27;用户已存在&#x27;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//根据定义的model新建一个对象并保存，第二个参数是保存成功后的回调函数</span></span><br><span class="line">            <span class="keyword">const</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(req.<span class="property">body</span>);</span><br><span class="line">            user.<span class="title function_">save</span>(<span class="keyword">function</span> (<span class="params">err, user</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(user);</span><br><span class="line">                res.<span class="title function_">send</span>(<span class="string">&#x27;登陆成功!&#x27;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure>

<p>到这里，前端后端数据库都连上了，代码也很清晰了。可以说我们的基础部分已经完成了。整个教程也到了尾声，本来打算介绍下测试，但是考虑到Angularjs即将被弃用就不打算再打一遍了，而Angular的cli配了一个开箱即用的测试框架，所以这部分内容以后写Angular相关的时候再详细介绍吧。至于开头说的time table这个项目，我是之前打过一遍的，功能也基本完整（还有测试相关代码）。这次写教程又根据文章节奏打了下，所以就到最简单的登录注册。并用commit记录内容。有心学习的同鞋可以去github的commit记录上一步步对照内容看下来。</p>
<hr>
<h1 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h1><ol>
<li>根据上面内容写的代码 <a href="https://github.com/dreamhuan/timetable">timetable</a></li>
<li>文初说的完整的项目代码 <a href="https://github.com/dreamhuan/timetable_fkq">timetable_fkq</a></li>
</ol>
]]></content>
      <categories>
        <category>MEAN</category>
      </categories>
      <tags>
        <tag>MEAN</tag>
        <tag>Nodejs</tag>
        <tag>AngularJS</tag>
        <tag>Express</tag>
        <tag>MongoDB</tag>
        <tag>front-end</tag>
        <tag>back-end</tag>
      </tags>
  </entry>
  <entry>
    <title>React</title>
    <url>/2021/06/25/React/</url>
    <content><![CDATA[<p>开局一张图，剩下全靠编</p>
<span id="more"></span>

<p><img src="/./React.png" alt="React"></p>
<h2 id="React"><a href="#React" class="headerlink" title="React &lt;17"></a>React &lt;17</h2><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>关键节点是 2015 年，es6 的诞生。在此之前 React 组件均是通过 React.createClass 创建，之后则可以直接用 es6 语法 extends Component 实现。从 15 年开始至今，class component 的写法深入人心，目前还占据主流地位。由此衍生出 HOC（代替原先的 mixin）、render props 等操作。</p>
<h3 id="FIber"><a href="#FIber" class="headerlink" title="FIber"></a>FIber</h3><p>底层大重构，为未来做铺垫。<a href="https://reactjs.org/docs/codebase-overview.html#reconcilers">reconcilers</a>是 react 对于不同平台（React DOM、React Native）的通用逻辑的抽离。协调算法会控制 React 的更新、生命周期等通用过程。<a href="https://reactjs.org/docs/implementation-notes.html">Stack Reconciler</a>时代的 React 对于挂载或者更新均需要递归遍历所有组件，触发变更。更新一旦开始就无法终止。<a href="https://github.com/acdlite/react-fiber-architecture">Fiber Reconciler</a>对于每个 react component 结点抽象出 fiber 结构，用二叉树连接整个 virtual dom。引入优先级概念，把原本递归的过程变成遍历的过程，中间可被中断。当然至今（2021.6）为止中断的开关还未被打开，目前称为 legacy mode 的状态虽然用了 fiber 结构但还是无法打断任务。react18 将正式开放 concurrent mode，展现 fiber 的完整能力。</p>
<h3 id="lifecycle"><a href="#lifecycle" class="headerlink" title="lifecycle"></a>lifecycle</h3><p>Fiber 架构下的必然情况。对于可被中断的低优先任务，打断后再执行就是从头开始，所以必然会导致相关生命周期被多次执行，所以加上了 unsafe 标记。同时补充了额外的生命周期函数，用于弥补可被中断情况下的一些行为。（getDerivedStateFromProps 也是在 render 阶段的生命周期函数，所以也会被执行多次，但是它拿不到 this）</p>
<h3 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h3><p>又一个革命性变更，让 function component 真正被重视（而不是原本作为 class component 附属）hooks 让 FC 有了组件完整的能力，也使逻辑复用更加容易。</p>
<h2 id="React-17"><a href="#React-17" class="headerlink" title="React 17"></a>React 17</h2><p>总所周知，react17 最大的新特性是没有新特性~ 然后看一眼<a href="https://reactjs.org/blog/2020/10/20/react-v17.html#changelog">changelog</a>可以往下滚好久…</p>
<h3 id="jsx-转换"><a href="#jsx-转换" class="headerlink" title="jsx 转换"></a>jsx 转换</h3><p>在之前的版本 jsx 会被编译成 React.createElement 的调用，所以即使代码中没用到 React 也需要导入。17 之后则编译成了 jsx(xxx)的函数调用，并且自动会帮助引入 jsx 的函数，所以如果代码中没有用上 React 就真的不需要导入啦</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 17之前</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 17之后，不需要手动加上 import React from &#x27;react&#x27;;</span></span><br><span class="line"><span class="comment">// Inserted by a compiler (don&#x27;t import it yourself!)</span></span><br><span class="line"><span class="keyword">import</span> &#123; jsx <span class="keyword">as</span> _jsx &#125; <span class="keyword">from</span> <span class="string">&#x27;react/jsx-runtime&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_jsx</span>(<span class="string">&#x27;h1&#x27;</span>, &#123; <span class="attr">children</span>: <span class="string">&#x27;Hello world&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 jsx 函数相对于 React.createElement 的额外改动可以看<a href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#detailed-design">这个 rfc</a></p>
<h3 id="事件委托挂载点变更"><a href="#事件委托挂载点变更" class="headerlink" title="事件委托挂载点变更"></a>事件委托挂载点变更</h3><p>看图 ↓ 一般来说对业务开发没影响，甚至方便了多个 React root 的操作。但是如果用了原生的 addEventlistener 就可能出问题。</p>
<p><img src="https://reactjs.org/static/bb4b10114882a50090b8ff61b3c4d0fd/21cdd/react_17_delegation.png" alt="React17事件委托挂载点变更"></p>
<h3 id="去除事件池"><a href="#去除事件池" class="headerlink" title="去除事件池"></a>去除事件池</h3><p>17 之前 React 使用事件池，事件执行完毕会回收，所以某些异步行为就拿不到 e.target.value 了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleChange</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="title function_">setData</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> (&#123;</span><br><span class="line">    ...data,</span><br><span class="line">    <span class="comment">// This crashes in React 16 and earlier:</span></span><br><span class="line">    <span class="attr">text</span>: e.<span class="property">target</span>.<span class="property">value</span>,</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useEffect-清理函数异步执行"><a href="#useEffect-清理函数异步执行" class="headerlink" title="useEffect 清理函数异步执行"></a>useEffect 清理函数异步执行</h3><p>值得注意的是，异步执行清理函数可能会导致的问题就是调用清理函数时某些 ref 的值可能已经发生变更。硬是要同步，用 useLayoutEffect</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// This is the effect itself.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// This is its cleanup.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="expirationTime-替换成-lanes-其实-v16-14-0-就换了"><a href="#expirationTime-替换成-lanes-其实-v16-14-0-就换了" class="headerlink" title="expirationTime 替换成 lanes(其实 v16.14.0 就换了)"></a>expirationTime 替换成 lanes(其实 v16.14.0 就换了)</h3><p>为了解决 Suspence 会阻塞其他任务的问题。（expirationTime 不能精确控制任务，只是笼统的一个大于某个时间任务全部更新。改造起来比较麻烦，lane 模型就只是用一个 31 位的数来控制优先级，优先级全部用位运算来处理。可以做到更细颗粒度的控制）</p>
<p>具体看<a href="https://juejin.cn/post/6951206227418284063">这里</a></p>
<h2 id="React-18-alpha"><a href="#React-18-alpha" class="headerlink" title="React 18(alpha)"></a>React 18(alpha)</h2><p><a href="https://github.com/reactwg/react-18/discussions">讨论最新进展</a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, container)</span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(container)</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>)</span><br></pre></td></tr></table></figure>

<p>虽然 Fiber、调度、并发渲染已经算是很老的概念了，但是这个模型的威力在 18 版本才开始展现出来。React 团队用两年时间改造（重写）了 Stack Reconciler 至 Fiber Reconciler 现在终于能用了 😏</p>
<h3 id="Automatic-Batching"><a href="#Automatic-Batching" class="headerlink" title="Automatic Batching"></a>Automatic Batching</h3><p>batchedUpdates：批处理更新，总所周知，事件里面多次 setState 会合并到一起执行，这就是批处理。React 在 18 之前只有事件回调和生命周期函数内部会启动批处理，其他的地方不会比如原生事件（addEventListener）、异步行为（setTimeout、Promise）</p>
<p>原因很简单，React 在执行事件前设置了上下文，执行后又重置了，所以异步行为发生时上下文已经不是批处理得了。至于自己绑定的事件，它不归 React 管，连设置那一步都没有…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> batchedUpdates&lt;A, R&gt;(<span class="attr">fn</span>: <span class="function">(<span class="params">A</span>) =&gt;</span> R, <span class="attr">a</span>: A): R &#123;</span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext</span><br><span class="line">  executionContext |= <span class="title class_">BatchedContext</span> <span class="comment">// 【设置】</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(a)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    executionContext = prevExecutionContext <span class="comment">// 【重置】</span></span><br><span class="line">    <span class="comment">// If there were legacy sync updates, flush them at the end of the outer</span></span><br><span class="line">    <span class="comment">// most batchedUpdates-like method.</span></span><br><span class="line">    <span class="keyword">if</span> (executionContext === <span class="title class_">NoContext</span>) &#123;</span><br><span class="line">      <span class="title function_">resetRenderTimer</span>()</span><br><span class="line">      <span class="title function_">flushSyncCallbacksOnlyInLegacyMode</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那 18 如何实现 Automatic Batching 呢？直接不用 BatchedContext 就行了。他在第一次触发后记录 lanes，后续多次触发发现 lanes 一样就不管，lanes 不一样就调度。最后过一段时间后会执行更新。（“一段时间”由优先级决定）</p>
<h3 id="CM-Concurrent-Mode"><a href="#CM-Concurrent-Mode" class="headerlink" title="CM(Concurrent Mode)"></a>CM(Concurrent Mode)</h3><p>只有在 18 才开放<code>ReactDOM.createRoot</code>api，用于开启<code>Concurrent Mode</code>，而原本的<code>ReactDOM.render</code>也同样保留（他的行为和原本完全一致）。Concurrent Mode 最大的区别就是任务可被打断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// performSyncWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performConcurrentWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopConcurrent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !<span class="title function_">shouldYield</span>()) &#123;</span><br><span class="line">    <span class="title function_">performUnitOfWork</span>(workInProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，只是多了一个 shouldYield 的判定</p>
<h3 id="Streaming-SSR"><a href="#Streaming-SSR" class="headerlink" title="Streaming SSR"></a>Streaming SSR</h3><p>新 api：pipeToNodeWritable。增强了 SSR 的能力，原先需要获取完整内容后通过 renderToString 实现，现在支持数据延时获取，组件懒加载（结合 Suspense）</p>
<p><a href="https://codesandbox.io/s/festive-star-9hfqt?file=/server/render.js">示例</a></p>
<h3 id="New-APIs"><a href="#New-APIs" class="headerlink" title="New APIs"></a>New APIs</h3><ol>
<li><p><a href="https://github.com/reactwg/react-18/discussions/41">startTransition</a></p>
<p>效果：标记回调函数为低优先级更新，对于 Slow rendering 和 Slow network 可以考虑使用，类似官方帮我们维护 loading 了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; startTransition, useTransition &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [isPending, startTransition] = <span class="title function_">useTransition</span>(&#123; <span class="attr">timeoutMs</span>: <span class="number">2000</span> &#125;)</span><br><span class="line">  <span class="comment">// 用hook的会透出一个pedding状态，不需要的话可以直接用React暴露的startTransition</span></span><br><span class="line">  <span class="title function_">startTransition</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setSearchQuery</span>(input)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;isPending ? &#x27; Loading...&#x27; : null&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码，只是开启一个标记而已。代码均为同步执行，这个标记降低了任务的优先级</span></span><br><span class="line"><span class="keyword">let</span> isInTransition = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">startTransition</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  isInTransition = <span class="literal">true</span></span><br><span class="line">  <span class="title function_">fn</span>()</span><br><span class="line">  isInTransition = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setState</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  stateQueue.<span class="title function_">push</span>(&#123;</span><br><span class="line">    <span class="attr">nextState</span>: value,</span><br><span class="line">    <span class="attr">isTransition</span>: isInTransition,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>useDeferredValue</p>
<p>相当于官方 debounce，值得注意的是 timeoutMs 并不是延时多久触发而是最长延时。如果组件性能好的话这个延时几乎可以忽略（所以并不能替代 debonce 本身）。使用场景是对于复杂组件渲染导致影响了输入的交互，可以适当延时渲染保证输入的流畅性（某种程度上牺牲一致性）另外，这个 api 某种程度上是对上面那个的补充，几乎可以用上面那个实现同样功能</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [text, setText] = <span class="title function_">useState</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> deferredText = <span class="title function_">useDeferredValue</span>(text, &#123; <span class="attr">timeoutMs</span>: <span class="number">2000</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* Keep passing the current text to the input */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;text&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      ...</span></span><br><span class="line"><span class="language-xml">      &#123;/* But the list is allowed to &quot;lag behind&quot; when necessary */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">MySlowList</span> <span class="attr">text</span>=<span class="string">&#123;deferredText&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo：<a href="https://codesandbox.io/s/pensive-shirley-wkp46">before</a> <a href="https://codesandbox.io/s/infallible-dewdney-9fkv9">after</a></p>
</li>
<li><p>Suspense</p>
<p>这玩意大家比较熟就不多说了，18 增加了 SSR 的 Suspense 能力（需要新的 SSR api 才能支持）</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Comments</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Comments.js&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">;<span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Spinner</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Comments</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h2><p><a href="https://github.com/reactjs/rfcs/pulls">React rfc 仓库</a></p>
<blockquote>
<p><strong>请求意见稿</strong>（英语：<strong>R</strong>equest <strong>f</strong>or <strong>C</strong>omments，缩写：<strong>RFC</strong>），又翻译作<strong>意见征求</strong>，<strong>意见请求</strong>，<strong>请求评论</strong>[<a href="https://zh.wikipedia.org/wiki/RFC#cite_note-1">1]</a>是由<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84">互联网工程任务组</a>（IETF）发布的一系列<a href="https://zh.wikipedia.org/wiki/%E5%82%99%E5%BF%98%E9%8C%84">备忘录</a>。文件收集了有关<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF">互联网</a>相关信息，以及<a href="https://zh.wikipedia.org/wiki/UNIX">UNIX</a>和互联网<a href="https://zh.wikipedia.org/wiki/%E7%A4%BE%E7%BE%A4">社区</a>的软件文件，以编号排定。目前RFC文件是由<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E4%BC%9A">互联网协会</a>（ISOC）<a href="https://zh.wikipedia.org/wiki/%E8%B4%8A%E5%8A%A9">赞助</a>发行。</p>
</blockquote>
<p>以上是维基百科定义的 RFC。现在广义的 RFC 更倾向于类似“js 提案”的概念，由开发团队或者协作维护者发起的对于一项有重大影响的变更的文档说明，开放给社区讨论，大家一起头脑风暴完善这个“提案”（采纳或否定由开发组决定）</p>
<h3 id="React-Server-Components"><a href="#React-Server-Components" class="headerlink" title="React Server Components"></a>React Server Components</h3><p>RSC 基本思路某种意义上可以类比 HMR（热更新），只不过 HMR 是服务端检测到文件变更后主动把变更后的 chunk 发送客户端，RSC 是触发某些交互后请求服务端，由服务端执行具体的逻辑，最后把渲染完的组件 chunk 发送到客户端再由客户端启动更新。这样的好处是显而易见的，组件可以保存状态，同时减轻浏览器压力（当然相当于压力转移到了服务端），还能减小包体积。</p>
<p>描述：<a href="https://github.com/josephsavona/rfcs/blob/server-components/text/0000-server-components.md#update-refetch-sequence">RFC: React Server Components</a></p>
<p>讨论：<a href="https://github.com/reactjs/rfcs/pull/188">(PR)RFC: React Server Components</a></p>
<p><a href="https://react-server-components.musicfe.dev/">在线体验</a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NodeEditor.client.js - Client Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">NoteEditor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> note = props.<span class="property">note</span></span><br><span class="line">  <span class="keyword">const</span> [title, setTitle] = <span class="title function_">useState</span>(note.<span class="property">title</span>)</span><br><span class="line">  <span class="keyword">const</span> [body, setBody] = <span class="title function_">useState</span>(note.<span class="property">body</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateTitle</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setTitle</span>(event.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">updateBody</span> = (<span class="params">event</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setTitle</span>(event.<span class="property">target</span>.<span class="property">value</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">submit</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...save note...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;...&quot;</span> <span class="attr">method</span>=<span class="string">&quot;...&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;submit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;updateTitle&#125;</span> <span class="attr">value</span>=<span class="string">&#123;title&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;body&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;updateBody&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;body&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note.server.js - Server Component</span></span><br><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">&#x27;db.server&#x27;</span></span><br><span class="line"><span class="comment">// (A1) We import from NoteEditor.client.js - a Client Component.</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">NoteEditor</span> <span class="keyword">from</span> <span class="string">&#x27;NoteEditor.client&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Note</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id, isEditing &#125; = props</span><br><span class="line">  <span class="comment">// (B) Can directly access server data sources during render, e.g. databases</span></span><br><span class="line">  <span class="keyword">const</span> note = db.<span class="property">posts</span>.<span class="title function_">get</span>(id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;note.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">section</span>&gt;</span>&#123;note.body&#125;<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* (A2) Dynamically render the editor only if necessary */&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;isEditing ? <span class="tag">&lt;<span class="name">NoteEditor</span> <span class="attr">note</span>=<span class="string">&#123;note&#125;</span> /&gt;</span> : null&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以，跟 SSR 的区别是什么？</p>
<ol>
<li>SSR 是在 Server 进行渲染，然后把渲染得到的 HTML 返回给 Client；而这个 Server Component，所有组件，不管 Server 组件还是 Client 组件，都是在 Client 进行渲染。只不过 Server 组件会自带一些在 Server 端获取的数据放在 props 里，这样就不用在 Client 再进行请求了。</li>
<li>SSR 因为每个请求都是一个新的 HTML，就相当于两个应用，你的应用都变了，那你原来应用里的状态肯定都丢了；但是 Server Component 不管你向 Server 请求多少次，都是同一个 HTML，同一个应用，你的状态不会丢。</li>
</ol>
<p>如何结合使用？</p>
<p>你会发现，使用 Server Component 是完全没法 SEO 的，因为 Server 返回的不是 HTML。其实官方也提过，我们可以结合起来用：</p>
<ol>
<li>我们的首页请求 Server 的&#x2F;路径，这个路径对应的是 SSR 渲染</li>
<li>Client 拿到 SSR 返回 HTML 后，后续的组件，请求 Server 的&#x2F;component 路径，这个路径对应的是 Server Component</li>
</ol>
<p>作者：达达 XxjzZ<br>链接：<a href="https://www.zhihu.com/question/435921124/answer/1641235418">https://www.zhihu.com/question/435921124/answer/1641235418</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>END</p>
<p><img src="http://img.bqb12.com/Uploads/vod/2019-10-24/gx2eqbkgtoq.jpg" alt="学不动了"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React 生命周期图</a></p>
<p><a href="https://juejin.cn/post/6894204813970997256">十五分钟读懂 React 17</a></p>
<p><a href="https://reactjs.org/blog/2020/08/10/react-v17-rc.html#other-breaking-changes">React v17.0 Release Candidate: No New Features</a></p>
<p><a href="https://blog.openreplay.com/react-18-is-out-this-is-what-you-need-to-know">React 18 Is Out! This Is What You Need to Know</a></p>
<p><a href="https://reactjs.org/docs/concurrent-mode-patterns.html">Concurrent UI Patterns (Experimental)</a></p>
<p><a href="https://mp.weixin.qq.com/s/yXXnPc43VyvJs0bpiIpJzQ">Automatic batching</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzkzMjIxNTcyMA==&mid=2247486768&idx=1&sn=c749b954277674d71aaac94e9362f15e&chksm=c25e63f7f529eae1b2f9503dbb0e888f65445322a418d4535fda94b080032ed58a566a9b02d7&cur_album_id=1783121402896678912&scene=189#rd">startTransition</a> (<a href="https://react-fractals-git-react-18-swizec.vercel.app/">demo</a>)</p>
<p><a href="https://github.com/reactwg/react-18/discussions/65">Real world example: adding startTransition for slow renders</a></p>
<p><a href="https://github.com/reactwg/react-18/discussions/37">New Suspense SSR Architecture in React 18</a></p>
<p><a href="https://betterprogramming.pub/the-future-of-react-server-components-90f6e3e97c8a">The Future of React: Server Components</a></p>
<p><a href="https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html">Introducing Zero-Bundle-Size React Server Components</a></p>
<p><a href="https://www.zhihu.com/question/435921124">如何看待 React Server Components？</a></p>
]]></content>
  </entry>
  <entry>
    <title>Rxjs简介</title>
    <url>/2018/03/18/Rxjs%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>谈谈Rxjs库的基本原理和使用。</p>
<span id="more"></span>

<h1 id="Rxjs库"><a href="#Rxjs库" class="headerlink" title="Rxjs库"></a>Rxjs库</h1><p>Rxjs是时下比较受欢迎的RP范式的一个库，RP是响应式编程的意思，就是说对于c&#x3D;a+b，a，b的变化均会导致c的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = a+b;<span class="comment">//3</span></span><br><span class="line">a = <span class="number">10</span>;<span class="comment">//c还是3，就不是响应式的</span></span><br></pre></td></tr></table></figure>

<p>换成响应式的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Rx</span>.<span class="title class_">Subject</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Rx</span>.<span class="title class_">Subject</span>();</span><br><span class="line"><span class="keyword">let</span> c = a</span><br><span class="line">    .<span class="title function_">combineLatest</span>(b, <span class="function">(<span class="params">total, now</span>) =&gt;</span> total + now) <span class="comment">// a+b</span></span><br><span class="line">    .<span class="title function_">subscribe</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br><span class="line">a.<span class="title function_">next</span>(<span class="number">1</span>);</span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">2</span>);<span class="comment">// 输出3</span></span><br><span class="line">a.<span class="title function_">next</span>(<span class="number">10</span>);<span class="comment">// 输出12</span></span><br></pre></td></tr></table></figure>

<p>这里需要引入Rxjs的库，那么什么是Rxjs呢？应用官网的话“RxJS 是使用 Observables 的响应式编程的库，它使编写异步或基于回调的代码更容易。”emmmmmm…说和没说一样。。。那我用自己的理解说一下，Rxjs大概就是把一切数据都看做是流，然后所有的操作都是对流的变幻，每当流里面出来一个新的值都会经过一系列预设的操作得到相应的结果。应用响应式的思想可以让结果同步变化，应用函数式的思想可以让流处理变得十分方便。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Rx</span>.<span class="title class_">Subject</span>();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Rx</span>.<span class="title class_">Subject</span>();</span><br><span class="line"><span class="keyword">let</span> doublea = a.<span class="title function_">map</span>(<span class="function"><span class="params">d</span> =&gt;</span> d * <span class="number">2</span>); <span class="comment">//2*a</span></span><br><span class="line"><span class="keyword">let</span> squareb = b.<span class="title function_">map</span>(<span class="function"><span class="params">d</span> =&gt;</span> d * d); <span class="comment">//b^2</span></span><br><span class="line"><span class="keyword">let</span> c = doublea</span><br><span class="line">    .<span class="title function_">combineLatest</span>(squareb, <span class="function">(<span class="params">total, now</span>) =&gt;</span> total + now) <span class="comment">// 2*a+b^2</span></span><br><span class="line">    .<span class="title function_">subscribe</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br><span class="line">a.<span class="title function_">next</span>(<span class="number">1</span>);</span><br><span class="line">b.<span class="title function_">next</span>(<span class="number">2</span>); <span class="comment">//输出6</span></span><br><span class="line">a.<span class="title function_">next</span>(<span class="number">10</span>); <span class="comment">//输出24</span></span><br></pre></td></tr></table></figure>

<p>这里的map，combineLatest都是流处理函数，最后的subscribe是流订阅函数，只有被订阅的流才可以真正触发（订阅就类似于函数调用，没有订阅的流就只是一些步骤的定义，只有订阅了流才工作）</p>
<p>上面说了一堆就是Rxjs入个门，Rxjs最大的魅力就是丰富多样的流处理函数，对于那么多的处理函数官网的查询机制也很完善，可以去体验下。</p>
<p>对于Angular中，是默认使用Rxjs库的，比如常用的HTTP请求。我们先对aaa发起一个get请求，然后json化后取出bbb字段，最后log出来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">http</span>.<span class="title function_">get</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">data</span>=&gt;</span>data.<span class="title function_">json</span>())</span><br><span class="line">    .<span class="title function_">map</span>(<span class="function"><span class="params">data</span>=&gt;</span>data.<span class="property">bbb</span>)</span><br><span class="line">    .<span class="title function_">subscribe</span>(<span class="variable language_">console</span>.<span class="property">log</span>);</span><br></pre></td></tr></table></figure>

<h1 id="进一步学习"><a href="#进一步学习" class="headerlink" title="进一步学习"></a>进一步学习</h1><p><a href="https://ithelp.ithome.com.tw/users/20103367/ironman/1199">30 天精通 RxJS</a><br><a href="https://zhuanlan.zhihu.com/p/34314169">使用响应式编程来实现简易版的无限滚动加载</a><br><a href="http://cn.rx.js.org/">Rxjs官网</a></p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>front-end</tag>
        <tag>Rxjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/03/23/hello-world/</url>
    <content><![CDATA[<p>hexo hello world</p>
<span id="more"></span>

<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h2 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h2 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h2 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git从入门到放弃</title>
    <url>/2021/05/25/git%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<p>git对文件和commit的操作命令简介</p>
<span id="more"></span>

<h2 id="oh-my-zsh-plugins"><a href="#oh-my-zsh-plugins" class="headerlink" title="oh-my-zsh plugins"></a>oh-my-zsh plugins</h2><p>FEer应该都配了iterm2、zsh、oh-my-zsh。毕竟mac的terminal难用的一笔…开始前先提oh-my-zsh的plugins是因为它默认给了个git的plugin，提供了海量alias。非常好用！</p>
<p>oh-my-zsh源代码在<code>~/.oh-my-zsh</code>（可以通过<code>echo $ZSH</code>查看）配置文件在<code>~/.zshrc</code>。</p>
<h3 id="git-插件提供的alias"><a href="#git-插件提供的alias" class="headerlink" title="git 插件提供的alias"></a>git 插件提供的alias</h3><p>两种方法查看</p>
<ol>
<li>看<code>~/.oh-my-zsh/plugins/git/README.md</code>或者同目录下的<code>git.plugin.zsh</code></li>
<li>命令行直接输<code>alias | grep git</code>看所有的alias</li>
</ol>
<p>常用的status、fetch、pull、push都有简短的alias，可以用起来提高敲命令效率，并且有些alias可以看做最佳实践比如<code>alias glol=&quot;git log --graph --pretty=&#39;%Cred%h%Creset -%C(auto)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39;&quot;</code></p>
<p>当然vscode已经有了一键显示commit history的功能了…</p>
<h3 id="其它常用插件（还有推荐的欢迎补充）"><a href="#其它常用插件（还有推荐的欢迎补充）" class="headerlink" title="其它常用插件（还有推荐的欢迎补充）"></a>其它常用插件（还有推荐的欢迎补充）</h3><ul>
<li><p>wd：设置路径别名，可以直接到达</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/work/developer-product $ wd add pro</span><br><span class="line">~/work/developer-product $ wd list</span><br><span class="line"> * All warp points:</span><br><span class="line">pro  -&gt;  ~/work/developer-product</span><br><span class="line">~/work/developer-product $ <span class="built_in">cd</span> ~</span><br><span class="line">~ $ wd pro</span><br><span class="line">~/work/developer-product $</span><br></pre></td></tr></table></figure>
</li>
<li><p>z：记录路径频率，之后输入路径部分名字就可以进入（和autojump一样效果，就是z不用另外安装）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~ $ z pro</span><br><span class="line">~/work/developer-product $</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a>（需要另外安装）：命令高亮</p>
</li>
<li><p><a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a>（需要另外安装）：记录历史输入的命令并提供输入建议，按→上屏</p>
</li>
<li><p>last-working-dir：打开新的session自动到当前目录（当前目录指的是最后cd的目录，不是当前窗口的目录）</p>
</li>
</ul>
<p>不用另外安装的直接在<code>~/.zshrc</code>的plugins&#x3D;(git xxx)里面写就好了，空格分隔。要另外安装的除了要在这里面写一下以外还有clone相应代码到<code>oh-my-zsh</code>的custom的plugins下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<h2 id="对文件的操作【全都是高危命令】"><a href="#对文件的操作【全都是高危命令】" class="headerlink" title="对文件的操作【全都是高危命令】"></a>对文件的操作【全都是高危命令】</h2><p>首先解释下“高危命令”，就是会使你的代码找不回来的命令，所以每一个都要想清楚在使用！</p>
<p>对于覆盖workspace的命令vscode可以直接撤销编辑，所以建议在打开vscode并且打开那个文件的情况下使用，手滑了还能撤销…（这里推荐下vscode一个插件Local History，会隔一段时间记录文件变动）</p>
<p>三个区域命名约定：工作区：workspace；暂存区：index；仓库的某个分支：branch。</p>
<p>变量命名约定：命令中<code>[xxx]</code>这里<code>xxx</code>是变量，后面说明的<code>[xxx]</code>也表示命令中的变量</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>checkout</p>
<ol>
<li><p><code>git checkout [branch name] [file path]</code> </p>
<p>用<code>[branch]</code>的<code>[file]</code>覆盖workspace和index的<code>[file]</code>，<strong>强制覆盖</strong></p>
</li>
<li><p><code>git checkout -- [file path]</code> </p>
<p>用index的<code>[file]</code>覆盖workspace的<code>[file]</code>，<strong>强制覆盖</strong></p>
</li>
</ol>
</li>
<li><p>reset</p>
<ol>
<li><p><code>git reset [branch name] [file path]</code> </p>
<p>用<code>[branch]</code>的<code>[file]</code>覆盖index的<code>[file]</code>，<strong>强制覆盖</strong></p>
</li>
</ol>
</li>
</ul>
<p>注1：当前分支<code>[branch name]</code>用<code>HEAD</code>。</p>
<p>注2：好像没有从<code>HEAD</code>绕过<code>index</code>到workspace的命令。</p>
<p><img src="/./1.png" alt="git 文件操作命令"></p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol>
<li><p>查看某个文件和另一个分支的差异。(reset)</p>
</li>
<li><p>merge出现冲突爆炸后抢救一下。(checkout) </p>
<p>类似于merge参数 -X theirs，然后可以手动吧自己的改动加上去</p>
</li>
</ol>
<h2 id="对commit的操作"><a href="#对commit的操作" class="headerlink" title="对commit的操作"></a>对commit的操作</h2><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>cherry-pick</p>
<ol>
<li><p><code>git cherry-pick [commit id]</code>（多个commit空格分隔）</p>
<p>把某个commit添加到当前commit后面。</p>
<p>因为一个commit记录的是与上一个commit的差异，所以可能pick完会有冲突，手动解决冲突后可以自己走add-&gt;commit流程也可以add完后<code>git cherry-pick --continue</code>（建议用continue），一般来讲冲突会出现在某个文件有多次改动但是只pick了其中某一次的改动，但并不建议这么做。就是说如果cherry-pick出现冲突了那思考下有没有别的解决方案。</p>
</li>
</ol>
</li>
<li><p><a href="http://jartto.wang/2018/12/11/git-rebase/">rebase</a></p>
<ol>
<li><p><code>git rebase [branch name]</code></p>
<p>找到当前分支和目标branch的分叉点然后把分叉点到最新的commit一个一个附加到目标branch的最前面。中间可能会出现无数个冲突，解决冲突后<code>git rebase --continue</code>改变主意了不想rebase了就<code>git rebase --abort</code></p>
</li>
<li><p><code>git rebase -i [commit id]</code> </p>
<p>整理这个id之后的所有commit。执行后会出现一个文件让你编辑，那个文件的下面会有每个命令的说明。一般来说就为了把多个commit合并到一起的话就<code>git rebase -i HEAD~3</code>然后出现三个pick，第一行pck改成r，下面两行pick改成s就完事了，后面编辑message然后保存就行。</p>
</li>
</ol>
</li>
<li><p>reset</p>
<ol>
<li><p><code>git reset [--soft/hard] [commit id]</code></p>
<p>没有任何参数就移动HEAD指针到对应commit，并重置index。从那个commit到最新的commit的那些改动全部放在工作区。加上–soft是不重置index，那些改动全部在index和工作区。加–hard是重置index和工作区。</p>
</li>
</ol>
</li>
<li><p>revert</p>
<ol>
<li><p><code>git revert [commitid]</code></p>
<p>自动生成一个commit，内容与<code>[commitid]</code>对应的commit相反。注意：revert一个比较久远的commit时有很大概率会有冲突。另外，如果revert一个merge commit，那么那个commit的内容就再也merge不进去了。除非把revert产生的commit再revert掉。</p>
</li>
<li><p><code>git revert [较旧的commitid]..[较新的commitid]</code></p>
<p>把区间（左开右闭）内的commit全部revert了。新旧commitid顺序反了会报错。左开右闭指的是较旧的commit不会revert，revert从较旧的后面那个开始到较新的commit，revert的顺序是从新到旧的（commit顺序反一下）</p>
</li>
</ol>
</li>
</ul>
<h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ol>
<li>commit错分支了（cherry-pick + reset hard 或者reset + checkout）</li>
<li>合并commit&#x2F;美化commit树（rebase）</li>
<li>把仓库炸了（reset &#x2F; revert &#x2F; 删了重拉）</li>
</ol>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>stash</p>
<ol>
<li><p><code>git stash push</code> </p>
<p>把index的内容放入暂存区</p>
</li>
<li><p><code>git stash pop</code> </p>
<p>把暂存区的内容放回index然后从暂存区删除，如果出现冲突则需要手动解决冲突并且不会删除暂存区，要手动drop</p>
</li>
<li><p><code>git stash drop</code> </p>
<p>删除暂存区最新一个stash，可以指定id：<code>git stash drop stash@&#123;[id]&#125;</code>，id通过list命令获取。注意每次删除stash后id会修改，id恒为0开始的数列，删了<code>stash@&#123;2&#125;</code>那么原本的<code>stash@&#123;3&#125;</code>就变成了<code>stash@&#123;2&#125;</code>，后面依次往前挪</p>
</li>
<li><p><code>git stash list</code> </p>
<p>列出stash列表，最前面显示的是id</p>
</li>
<li><p><code>git stash show --text stash@&#123;[id]&#125;</code></p>
<p>查看stash内容</p>
</li>
</ol>
</li>
<li><p>worktree</p>
<ol>
<li><p><code>git worktree add -b [new branch] [new fold path] [from branch]</code></p>
<p>创建一个worktree关联<code>[fold]</code>与<code>[branch]</code>。<code>[from branch]</code>省略的话默认是<code>HEAD</code>。</p>
<p>等效于在<code>[fold]</code>下又clone了一份代码并且切换到<code>[branch]</code>分支（不完全一致，比clone一份更优雅）。然后我们cd到<code>[fold]</code>里会发现就是<code>[branch]</code>分支（不cd到<code>[fold]</code>在原路径是无法checkout到新分支的）</p>
</li>
<li><p><code>git worktree add [new fold path] [branch]</code></p>
<p>上面命令的简化版。创建一个<code>[fold]</code>并关联<code>[branch]</code>，<code>[branch]</code>必须已存在（其实给个commitid也可以）。不给出<code>[branch]</code>就从<code>HEAD</code>切一个分支，分支名为文件夹名。</p>
</li>
<li><p><code>git worktree list</code></p>
<p>列出所有的worktree</p>
</li>
<li><p><code>git worktree prune</code></p>
<p>删除文件夹已经被删的worktree。</p>
</li>
</ol>
</li>
</ul>
<p>把以下代码加到<code>~/.zshrc</code>末尾。函数名即为命令名，可以自己换一个顺手的。对应项目的<code>.gitignore</code>要加上<code>node_modules</code>（注意结尾没有&#x2F;）、<code>.worktree</code>。</p>
<p>  使用：<code>gwta [new branch name] [vscode name]</code>（一般不需要第二个参数…）</p>
<p>  效果：以输入的分支名从<code>origin/master</code>切一个新的worktree。如果输入的分支在远程存在就从远程拉取并建立关联。</p>
<p>  我中间加了行输出有颜色的echo，可以明确分支远程是否存在<code>echo -e &quot;\e[1;32m create worktree from [ $BRANCH ] in &#39;.worktree/$1&#39; \e[0m&quot;</code></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">gwta</span></span>() &#123;</span><br><span class="line">  PROJECT_DIR=<span class="variable">$PWD</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 更新分支列表</span></span><br><span class="line">  git fetch --all</span><br><span class="line">  <span class="comment"># 搜索远程分支,并裁剪到origin/xxx</span></span><br><span class="line">  BRANCH=$(git branch -a | grep <span class="string">&quot;$1$&quot;</span> |  <span class="built_in">cut</span> -c 11- )</span><br><span class="line">  <span class="comment"># 没搜到就默认 origin/master</span></span><br><span class="line">  BRANCH=<span class="variable">$&#123;BRANCH:-origin/master&#125;</span></span><br><span class="line">  <span class="comment"># 创建 worktree</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">&quot;\e[1;32m create worktree from [ <span class="variable">$BRANCH</span> ] in &#x27;.worktree/<span class="variable">$1</span>&#x27; \e[0m&quot;</span></span><br><span class="line">  git worktree add -b <span class="variable">$1</span> .worktree/<span class="variable">$1</span> <span class="variable">$BRANCH</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">cd</span> <span class="string">&quot;.worktree/<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="comment"># node_modules 软链接</span></span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$PROJECT_DIR</span>/node_modules node_modules</span><br><span class="line">  <span class="comment"># 如果要设置  vscode 项目标题</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="variable">$2</span> ]; <span class="keyword">then</span></span><br><span class="line">  TITLE=<span class="string">&#x27;$&#123;activeEditorShort&#125;$&#123;separator&#125; &#x27;</span><span class="variable">$2</span></span><br><span class="line">  <span class="built_in">mkdir</span> -p .vscode</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;&#123;</span></span><br><span class="line"><span class="string">  \&quot;window.title\&quot;: \&quot;<span class="variable">$TITLE</span>\&quot;</span></span><br><span class="line"><span class="string">&#125;&quot;</span> &gt; ./.vscode/settings.json</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">  code .</span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$PROJECT_DIR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><ol>
<li>某项目开发一半同仓库下临时有个bug要改。</li>
<li>同个代码仓库下同时有一大堆需求要做。</li>
</ol>
<p>这两场景其实一个意思。用stash的方案就是先<code>git stash push</code>，然后该干嘛干嘛。好了之后回到feature分支<code>git stash pop</code>。这样看上去很方便但是如果需求一多反复push、pop是很麻烦的。。。</p>
<p>worktree提供了更优雅的方案，先用以上函数创建worktree。（我这边是gwta，你可以改函数名改成自己顺手的命令…）代码会在当前目录.worktree下，并且已经建立好了node_modules的软链。cd到里面的目录正常add-&gt;commit-&gt;push完事。发布完成后可以删除这个目录，然后在原目录执行<code>git worktree prune</code>就会删除这个worktree。然后在外面就可以切到新的分支了。</p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title>web study</title>
    <url>/2017/03/30/web-study/</url>
    <content><![CDATA[<p>大二前端课程的作业</p>
<span id="more"></span>

<h1 id="我的作业"><a href="#我的作业" class="headerlink" title="我的作业"></a>我的作业</h1><h2 id="实验1：-table布局"><a href="#实验1：-table布局" class="headerlink" title="实验1： table布局"></a><a href="https://dreamhuan.github.io/webStudy/%E5%AE%9E%E9%AA%8C1/index.html">实验1： table布局</a></h2><h2 id="实验2：-js事件练习"><a href="#实验2：-js事件练习" class="headerlink" title="实验2： js事件练习"></a><a href="https://dreamhuan.github.io/webStudy/%E5%AE%9E%E9%AA%8C2/index.html">实验2： js事件练习</a></h2><h2 id="实验3：-div布局"><a href="#实验3：-div布局" class="headerlink" title="实验3： div布局"></a><a href="https://dreamhuan.github.io/webStudy/%E5%AE%9E%E9%AA%8C3/index.html">实验3： div布局</a></h2><h2 id="实验4：-flex布局"><a href="#实验4：-flex布局" class="headerlink" title="实验4： flex布局"></a><a href="https://dreamhuan.github.io/webStudy/%E5%AE%9E%E9%AA%8C4/index.html">实验4： flex布局</a></h2><h2 id="实验5：-网格语义综合排版练习"><a href="#实验5：-网格语义综合排版练习" class="headerlink" title="实验5： 网格语义综合排版练习"></a><a href="https://dreamhuan.github.io/webStudy/%E5%AE%9E%E9%AA%8C5/index.html">实验5： 网格语义综合排版练习</a></h2><h2 id="实验6：-JQuery基本练习"><a href="#实验6：-JQuery基本练习" class="headerlink" title="实验6： JQuery基本练习"></a><a href="https://dreamhuan.github.io/webStudy/%E5%AE%9E%E9%AA%8C6/index.html">实验6： JQuery基本练习</a></h2><h2 id="实验7：-Bootstrap栅格练习"><a href="#实验7：-Bootstrap栅格练习" class="headerlink" title="实验7： Bootstrap栅格练习"></a><a href="https://dreamhuan.github.io/webStudy/%E5%AE%9E%E9%AA%8C7/index.html">实验7： Bootstrap栅格练习</a></h2><h2 id="实验9：-百度地图基本练习"><a href="#实验9：-百度地图基本练习" class="headerlink" title="实验9： 百度地图基本练习"></a><a href="https://dreamhuan.github.io/webStudy/%E5%AE%9E%E9%AA%8C9/index.html">实验9： 百度地图基本练习</a></h2><h2 id="期末project"><a href="#期末project" class="headerlink" title="期末project"></a><a href="https://github.com/dreamhuan/association">期末project</a></h2>]]></content>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2018/03/18/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>谈谈函数式编程在js的实践。</p>
<span id="more"></span>

<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>首先讲讲编程范式，所谓编程范式就是代码世界的方法论。大家比较熟的就是面向过程和面向对象了，这些范式并不是锁定语言的，但是有些却是需要语言特性支持。比如c就是常见的面向过程的编程范式语言，但是因为指针、结构体的存在让它也具有一定的面向对象的能力。java是常见的面向对象的语言，但是要是写类和方法时没有封装，继承的思想，那也不过是面向过程包上了一层class的外衣。</p>
<p>以上解释了范式不限定语言，那何为范式需要语言支持呢？这就提到函数式编程了，函数式编程范式的思想是把一切行为都用函数连接起来，每个函数都有确定的输出，整体就是一个y&#x3D;f(x)的形式，扩展下就有y&#x3D;f(g(t(x)))这样一层一层嵌套的函数调用。写的优雅一点就是gg&#x3D;g(t),ff&#x3D;f(g),y&#x3D;ff(x),可以看到这里把函数t作为函数g的参数了，然后组合出了新的函数gg，这里可以引出函数式编程的要求是具有吧函数作为参数传递的能力，官方点说法就是“函数是一等公民”。自然，这个也不是必要条件，只是个充分条件（函数是一等公民一定可以函数式，函数式不一定要函数是一等公民，但是需要多绕几个弯比如C++可以重载类的函数调用操作符就可以创造函数对象这种东西就可以做参数传递了）另外，函数式是一种思想，我们学习只是为了提高某些代码的简洁性和优雅性，不能为了函数式而函数式编程。</p>
<h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>扯了那么多，那函数式编程有啥用呢？为了提高某些代码的简洁性和优雅性。。。废话，具体点？传统编程中会有需要状态管理以及处理中间变量的情况，比如求和，那就需要一个sum变量，然后手动遍历数组每个数字并加到sum里面。恩很轻松就搞定了。那需要正负分开求和呢？那就加个if。。。需要求平方和呢？当然这个例子有点钻牛角尖，其实我想说明的是，随着需求的变多我们需要申明更多的变量来存储这个结果，一个大型的系统，变量越来越多状态也会更加复杂，就会趋于不可控，于是就出来很多状态管理机制比如有限状态机之类的。但是函数式的思想就是记录过程不记录结果，关注点从每一步做法转移到每个过程的拼接。好处就是定义一些基本函数后，有新的需求就把基础函数组装起来就可以了，比如arr.sum(), arr.bigthan0().sum(), arr.smallthan0().sum()</p>
<p>上面只是简单提了状态多带来的副作用（不好管理），函数式编程真正的优势是没有中间状态就可以不用担心状态被修改或者出现竞争导致的多线程下各种复杂问题，所以可以轻松应付高并发环境。</p>
<h2 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h2><p>函数式的一些基本概念</p>
<ol>
<li>函数没有副作用，就是所谓的纯函数。即函数对同一输入有相同输出，且不会修改外界的状态。</li>
<li>函数可以作为参数传入别的函数并在需要的时候调用，也可以从函数返回新的函数。就是所谓的高阶函数。</li>
<li>多个参数的函数可以进行参数拆解，返回新的函数（需要比较少的参数）就是所谓的科里化。科里化可以更好地函数复用。</li>
</ol>
<p>js中函数是一等公民，它是天生的支持函数式编程的语言，es6中箭头函数的引入又在写法上带来了便捷性（箭头函数还有更深的特性比如不产生this，只不过与这个主题无关），另外箭头函数的写法各个语言都有一定的支持（就是大名鼎鼎的lambda表达式）。然后js的Array对象有很多支持函数式的内置函数也给函数式编程带了很多便利，比如map，filter，reduce等。</p>
<p>比如花样求和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,-<span class="number">2</span>,-<span class="number">3</span>,-<span class="number">7</span>];</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum,item</span>)=&gt;</span>sum+item); <span class="comment">//求和</span></span><br><span class="line">arr.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> x&gt;<span class="number">0</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, x</span>) =&gt;</span> sum + x); <span class="comment">//正数求和</span></span><br><span class="line">arr.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x*x).<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, x</span>) =&gt;</span> sum + x); <span class="comment">//平方和</span></span><br></pre></td></tr></table></figure>

<p>可以看到就是map，reduce，filter的简单组合</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a,b</span>) =&gt; a+b;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = (<span class="params">f,a,b</span>) =&gt; <span class="title function_">f</span>(a,b)</span><br><span class="line"><span class="title function_">fun</span>(sum,<span class="number">1</span>,<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h1 id="进一步学习"><a href="#进一步学习" class="headerlink" title="进一步学习"></a>进一步学习</h1><p><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程</a><br><a href="https://coolshell.cn/articles/17524.html">如何读懂并写出装逼的函数式代码</a>(看看长长见识就好了，千万别写出这种代码…)</p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>front-end</tag>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title>前端技能树</title>
    <url>/2021/01/02/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%E6%A0%91/</url>
    <content><![CDATA[<p>终于从大学生转职成前端攻城狮，总要点一点技能树。</p>
<span id="more"></span>

<p>计划 2021 年把它写完把…</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="基础（传说中的基础中的基础-23333）"><a href="#基础（传说中的基础中的基础-23333）" class="headerlink" title="基础（传说中的基础中的基础 23333）"></a>基础（传说中的基础中的基础 23333）</h3><ul>
<li>(empty)<a href="">CPU</a></li>
<li>(empty)<a href="">浮点数</a></li>
<li>(empty)<a href="">网络</a></li>
<li></li>
</ul>
<h3 id="数据结构-算法"><a href="#数据结构-算法" class="headerlink" title="数据结构&amp;算法"></a>数据结构&amp;算法</h3><ul>
<li>(empty)<a href="">链表</a></li>
<li>(empty)<a href="">二叉树</a></li>
<li>(empty)<a href="">排序&amp;查找</a></li>
<li>(empty)<a href="">动态规划</a></li>
<li></li>
</ul>
<h3 id="刷点题"><a href="#刷点题" class="headerlink" title="刷点题"></a>刷点题</h3><ul>
<li>(empty)<a href="">a+b</a></li>
<li></li>
</ul>
<h2 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h2><h3 id="html-js-css-ts"><a href="#html-js-css-ts" class="headerlink" title="html&amp;js&amp;css&amp;ts"></a>html&amp;js&amp;css&amp;ts</h3><ul>
<li>(empty)<a href="">原型继承</a></li>
<li>(empty)<a href="">esnext</a></li>
<li>(empty)<a href="">ts 泛型</a></li>
<li>(empty)<a href="">css-float</a></li>
<li>(empty)<a href="">css-flex</a></li>
<li></li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>(empty)<a href="">xss</a></li>
<li>(empty)<a href="">csrf</a></li>
<li>(empty)<a href="">跨域</a></li>
<li></li>
</ul>
<h2 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h2><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><ul>
<li>(empty)<a href="">hooks</a></li>
<li>(empty)<a href="">ssr</a></li>
<li></li>
</ul>
<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li>(empty)<a href="">火焰图</a></li>
<li></li>
</ul>
<h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><ul>
<li>(empty)<a href="">简介</a></li>
<li></li>
</ul>
<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><ul>
<li>(empty)<a href="">简介</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓调试数据库</title>
    <url>/2017/11/15/%E5%AE%89%E5%8D%93%E8%B0%83%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>安卓sqlite的web可视化，便于调试时对数据进行操作</p>
<span id="more"></span>
<p>参考链接</p>
<blockquote>
<p><a href="http://www.jianshu.com/p/21bdf55f12d2">在 Android Studio 上调试数据库 ( SQLite )</a><br><a href="https://github.com/amitshekhariitbhu/Android-Debug-Database/issues/6">Issuues Open http://0.0.0.0:8080 in your browser</a></p>
</blockquote>
<p>第一个链接中，作者给了两个方案，一个是使用Android Studio的一个<strong>收费</strong>插件<code>SQLScout</code>，我等贫民直接跳过，第二种是一个开源项目<code>Android Debug Database</code>，可以在网页上打开查看并操作数据库，使用方法如下：<br>先在 module 的 build.gradle 里面添加（加在app&#x2F;build.gradle的dependencies里面）：<br><code>debugCompile &#39;com.amitshekhar.android:debug-db:1.0.0&#39;</code><br>让手机和电脑处于一个局域网下，当项目跑起来的时候，在 logcat 里面会打印出这么一行：<br><code>D/DebugDB: Open http://XXX.XXX.X.XXX:8080 in your browser</code><br>然后把地址复制到浏览器打开就好了。</p>
<p>然后我就遇到了一个问题，logcat输出的是0.0.0.0:8080，那我就很尴尬，去搜索了下AS3好多人都有这个问题，并在那个项目的Issues里找到了解决方案（具体的就是第二个链接）<br>打开命令行，运行<br><code>adb forward tcp:8080 tcp:8080</code><br>然后打开浏览器输入 <code>http://localhost:8080</code> 就好啦<br>要是运行上面命令出现问题：</p>
<ol>
<li>没把安卓sdk加入环境变量的进入sdk安装目录的platform-tools里执行</li>
<li>出现重定向拒绝或者说没权限的可能是端口冲突了，吧<strong>第一个</strong>8080改成别的数字比如8081，然后浏览器输入的也对应的改为8081就好了。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo新建文章</title>
    <url>/2017/03/24/hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>hexo常用命令相关笔记和使用说明</p>
<span id="more"></span>
<p>转自<a href="http://jingyan.baidu.com/article/63f236280da7770208ab3d27.html">百度经验</a><br>(部分修改)</p>
<p>hexo发布文章过程：</p>
<ol>
<li>hexo n “文章标题”</li>
<li>source&#x2F;_posts找“文章标题.md”文件并编写</li>
<li>hexo s  运行服务器</li>
<li>打开localhost:3000预览(默认是4000，修改端口在node_modules&#x2F;hexo-server&#x2F;index.js 第8行)</li>
<li>hexo g  生成静态文件</li>
<li>hexo d  发布</li>
</ol>
<p>hexo常用简写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<p>命令行中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;new article&quot;</span></span><br></pre></td></tr></table></figure>

<p>之后在source&#x2F;_posts目录下面，多了一个new-article.md的文件。</p>
<p>打开之后我们会看到：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">title: new article</span><br><span class="line">date: 2014-11-01 20:10:33</span><br><span class="line">tags:</span><br></pre></td></tr></table></figure>

<p>文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文。<br>文章的正文支持markdown格式，建议你先学习一下它的语法<br>。markdown不像html似的一大堆标签，很简单，只有几个符号。<br>新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。</p>
<p>属性<br>文章可以拥有如下属性：</p>
<table>
<thead>
<tr>
<th align="left">Setting</th>
<th align="center">Description</th>
<th align="right">Default</th>
</tr>
</thead>
<tbody><tr>
<td align="left">layout</td>
<td align="center">Layout</td>
<td align="right">post或page</td>
</tr>
<tr>
<td align="left">title</td>
<td align="center">文章的标题</td>
<td align="right"></td>
</tr>
<tr>
<td align="left">ate</td>
<td align="center">创建日期</td>
<td align="right">文件的创建日期</td>
</tr>
<tr>
<td align="left">pdated</td>
<td align="center">修改日期</td>
<td align="right">文件的修改日期</td>
</tr>
<tr>
<td align="left">omments</td>
<td align="center">是否开启评论</td>
<td align="right">true</td>
</tr>
<tr>
<td align="left">ags</td>
<td align="center">标签</td>
<td align="right"></td>
</tr>
<tr>
<td align="left">ategories</td>
<td align="center">分类</td>
<td align="right"></td>
</tr>
<tr>
<td align="left">ermalink</td>
<td align="center">url中的名字</td>
<td align="right">文件名</td>
</tr>
</tbody></table>
<p>动态博客中通过发布文章页面设置的各种属性，在hexo里要这样设置。</p>
<p>分类和标签<br>例如：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line"></span><br><span class="line">- 日记</span><br><span class="line"></span><br><span class="line">tags:</span><br><span class="line"></span><br><span class="line">- Hexo</span><br><span class="line">- node.js</span><br></pre></td></tr></table></figure>

<p>摘要<br>同wordpress一样，<code>&lt;!--more--&gt;</code>之上的内容为摘要。</p>
<p>layout<br>如果你修改了layout，在scaffolds文件夹里一定要有名字对应的模版文件，否则会采用默认模版。</p>
<p>文件名<br>在配置文件中的new_post_name项可以设置文件名，默认为:title，也就是你在命令行输入的名字。</p>
<p>文件名可以为下面几个变量和字符串常量的任意组合：</p>
<table>
<thead>
<tr>
<th align="left">Variable</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:title</td>
<td align="left">Escaped title (lower case and replace spaces with dash)</td>
</tr>
<tr>
<td align="left">:year</td>
<td align="left">Created year (4-digit)</td>
</tr>
<tr>
<td align="left">:month</td>
<td align="left">Created month (2-digit)</td>
</tr>
<tr>
<td align="left">:i_month</td>
<td align="left">Created month (Without leading zeros)</td>
</tr>
<tr>
<td align="left">:day</td>
<td align="left">Created day (2-digit)</td>
</tr>
<tr>
<td align="left">:i_day</td>
<td align="left">Created day (Without leading zeros)</td>
</tr>
</tbody></table>
<p>草稿<br>草稿相当于很多博客都有的“私密文章”功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new draft <span class="string">&quot;new draft&quot;</span></span><br></pre></td></tr></table></figure>

<p>会在source&#x2F;_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。<br>也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。</p>
<p>如果你希望强行预览草稿，更改配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">render_drafts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>或者，如下方式启动server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server --drafts</span><br></pre></td></tr></table></figure>

<p>下面这条命令可以把草稿变成文章，或者页面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>实习总结</title>
    <url>/2019/01/31/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在有赞共享前端实习了半年（18.7-19.1）总结下自我的收获和实习的体验。</p>
<span id="more"></span>

<p>首先是环境，用了 nvm 来控制 node 的版本，async&#x2F;await 只有 node8+才能用，新的项目都统一用 8.x，旧的项目用的是 node6 的（node 端不过 babel 编译，直接运行）。第一次使用 mac 对命令行不是很熟，配了下 iterm2 和 ohmyzsh，发现 mac 下的命令行真好用…原本 IDEA 的深度用户的我在接触了 vscode+iterm2 后表示真香～后来就是日常 iterm2 分 4 屏然后开 3-4 个 vscode。。。</p>
<p>然后是各种账号权限，本地生成了 rsa 加到 keychain，然后 ssh 连服务器，服务器环境有开发、测试、预发、线上，一般情况下用专门的发布平台来部署到对应的机器，极端情况需要直接 ssh 连服务器调试代码。内部系统比较多，包括代码仓库、文档系统、bug 跟踪、发布系统、项目跟踪、线上监控等，刚接触的时候一脸懵逼，每个平台都深入使用过才了解。有些平台是内部开发维护的，有些是购买的比如 jira。每个系统都有自己的功能，不同系统用在开发的不同阶段，提高效率。</p>
<p>我在 PC 组，一开始主要是熟悉开发套路，所以就是改改文案改改样式，把整个收到 bug 到修复 bug 到上线的流程走一遍。PC 端用的 React 全家桶，在学校时我主要写 Angular，所以赶紧花时间把 React 官网过了一遍。接手的第一个项目是 UI 改写。有个单独的平台原本是前端凭感觉做的，现在设计给了稿子，就需要把整体 UI 按照设计给的稿子做一遍。因为使用了 style-components，所以顺便学习了一下 css in js 的套路，感觉对组件的抽象要求比较高，有些样式有多种方案的需要考虑组件复用性高的方案。通过这个项目，对 React 开发也算入了门。后面几个项目涉及到数据请求，以及逻辑处理，更加深了对 React 的理解，期间看了《深入浅出 React 和 Redux》是我受益匪浅。然而有赞 PC 是多页中的单页，由 node 渲染基础模版，然后留一个 div 给 react 渲染组件。所以每个单页应用不是很复杂，也没必要使用 Redux 了。最后前端代码打包完上传到 cdn，留一个 hash 塞入 node 层模版中，所以 node 层也可以直接塞一些数据在 global 下，可以节省一些异步请求。</p>
<p>因为按业务划分，我是做会员业务的，所以 h5 和小程序的个人中心后来也从移动组划到了我们这里（据说是因为人不够？？）于是我就开始写 Vue 了。。。（h5 是 Vue 全家桶）主要就是一个个人中心页面。UI 上还好，没有什么比较骚的操作，有意思的地方在整体页面样子要根据 PC 后台的配置来，整个就是店铺装修的套路。另外 PC 端还需要展示预览效果，所以需要把整个页面分拆成组件后打包发布，以便于 PC 端使用。h5 要根据 PC 的配置比如主题色、组件位置、插件显示模式等。所以整个使用了 Vue 的动态组件，从后端读取 PC 上修改的页面配置，根据配置渲染不同的组件，对于有些组件需要另外的参数控制显示效果也是从配置中读取的。读取完配置后初始化 Vuex 的 store，UI 组件再根据 Vuex 的 state 渲染不同的样式。打包给 PC 的那份组件在提供默认的 Store。另外 PC 端在 React 里渲染 Vue 的组件个人感觉也比较骚，然而遗憾的是米有机会看他的源码就离职了。。。</p>
<p>然后是个人中心页面的小程序版本，UI 上和 h5 一致，技术上也没啥难点，就是体验了下小程序开发，小程序整体开发体验上和 shadowDOM 比较相似，但是因为微信提供的小程序框架基本上是个黑盒子，有些 api 的错误也很难查找原因，只能跟微信的人咨询，这种感觉就很蛋疼。在开发中曾经出现过一个调用微信的 api 报没有权限的 error，搞了好久才弄好，真是令人心力憔悴。。。</p>
<p>业务部分讲完了，讲讲技术部分把，也站在上层回顾下有赞前端的技术架构。首先，后端是基于 dubbo 的微服务架构，然后内部用 go 实现了一个代理框架 Tether 暴露一个 http 服务，微服务相关的部分都由 Tether 来处理（服务发现服务调用负载均衡等），暴露的 http 服务是让 node 调用的，比如 node 发一个 <code>POST www.demo.com:6666/i.am.a.long.package.name/iAmAServiceName.functionName</code> 到 Tether，Tether 会解析这个请求，然后转发到对应包名类名方法名的 java 接口（参数视 java 借口而定）并把 java 返回的数据过一层解析和封装，变成<code>&#123;code:200,data:&#123;k:666&#125;,message:&#39;xxx&#39;&#125;</code>的形式返回给 node。前端部分是 node + React&#x2F;Vue 的结构，node 部分是基于 koa 分装的 Astroboy 框架，已开源。在 Astroboy 基础上包装了业务层框架 youzan-framework。加了底层把业务方法调用改成 http 调用的形式。比如上面的 <code>POST www.demo.com:6666/i.am.a.long.package.name/iAmAServiceName.functionName</code>，开发者只需要写 <code>this.invoke(&#39;i.am.a.long.package.name.iAmAServiceName&#39;,&#39;functionName&#39;,[param1,param2])</code>youzan-framework 除了做方法解析，还针对 http 调用做了一些设置比如超时或者一些特定请求头等。在 youzan-framework 之上又针对不同的业务线（toB、toC）封装了两个不同的上层业务框架。因为有赞的业务 toB 部分基本是 PC 后台，toC 部分就是 h5 相关，所以这两业务框架基本 PC 的一套 h5 的一套，里面封装了不同的登陆态获取方式等。当然也有 toB 的 h5 页面（我当时做过一个），所以就会出现一个仓库既有 React 又有 Vue 的尴尬…但是他们基本不相干，就加两份打包配置而已…这三个框架都属于 node 层底层框架，业务开发基于他们进行。前端页面部分整体不是一个 SPA 而是多页中的单页。node 会渲染页面模板给浏览器，同时预留一个类似<code>&lt;div id=&#39;app-root&#39;&gt;&lt;/div&gt;</code>给 React&#x2F;Vue 来挂载。然后对于 PC 端部分，整个一级导航的每个项都有一个代码仓库，用 nginx 针对不同 url 来转发。可以做到独立开发独立部署。一个代码仓库负责一个一级导航下的整个二级导航。基本上每个二级导航都对应了 node 层一个模板页面，对于有三级导航的大多是 SPA 了。三级导航的 router 就由前端来控制。前端页面开发完后，会把 webpack 打包结果上传到 cdn，并把 hash 值写入配置文件。node 层渲染模板的时候会去读取配置文件的 hash 值，拼接成 cdn 的完整 url，并加到模板的 script 标签上。当然这一切都有 cli 负责整个流程的自动化进行。</p>
<p>最后讲讲有赞的技术积累。它有 zan-proxy、zan-api 等提高开发效率的工具也有 zent、vant 等组件库，还有比较丰富的文档网站。可以说在积累上是比较富裕的。zan-proxy 主要用于代理某些请求到本地，之前提了有赞是多个仓库通过 nginx 代理的，所以不可能本地跑整站的代码，就可以把具体业务部分的页面代理到本地的 node 服务进行调试开发。当然直接只运行这部分页面在本地开发也是可以的，但是有些需要依赖 cookie 等，使用代理可以更好的贴近线上的模式。它的原理是通过配置正则，符合某个正则模式的请求就会代理到本地某个端口暴露的服务。具体点比如 <a href="http://www.baidu.com/">www.baidu.com</a> 的 GET 请求代理到 localhost:8080 的 node 服务，这样别的还是会走线上的，进入到符合正则匹配的 url 时就走本地的了。zan-api 主要用于前后端接口定义，配合 zan-proxy 可以实现前端通过接口测试后联调时几乎不用再改前端代码，当然具体的 mock 数据需要自己编写。具体原理是某个接口的请求就走到一个统一的 mock 服务上，返回 mock 数据，整个过程处理数据是 mock 的别的完全一致，所以等后端开发完后只需要把这个接口的转发关掉就走到了后端那里。这两个工具个人感觉都比较使用，整体原理上也不难理解。可以较大程度提高开发效率。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象语法树(abstract syntax tree, AST)</title>
    <url>/2021/05/10/%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91(AST)/</url>
    <content><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract syntax tree</a></p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Computer_science">computer science</a>, an <strong>abstract syntax tree</strong> (<strong>AST</strong>), or just <strong>syntax tree</strong>, is a <a href="https://en.wikipedia.org/wiki/Directed_tree">tree</a> representation of the <a href="https://en.wikipedia.org/wiki/Abstract_syntax">abstract syntactic</a> structure of <a href="https://en.wikipedia.org/wiki/Source_code">source code</a> written in a <a href="https://en.wikipedia.org/wiki/Programming_language">programming language</a>. Each node of the tree denotes a construct occurring in the source code.</p>
</blockquote>
<p>抽象语法树（AST）就是由代码本身解析得到的一个树形结构</p>
<span id="more"></span>

<p>直接盗用 wikipedia 的图</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> b ≠ <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> a &gt; b</span><br><span class="line">    a := a − b</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    b := b − a</span><br><span class="line"><span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p><img src="/./Abstract_syntax_tree_for_Euclidean_algorithm.svg" alt="Abstract_syntax_tree_for_Euclidean_algorithm"><br><a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">图片来源</a></p>
<h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>至于为什么会有这么一个东西以及怎么来的就要祭出我们的编译原理了：</p>
<p><img src="http://qiankunli.github.io/public/upload/basic/compile_process.jpg" alt="compile_process"><br><a href="http://qiankunli.github.io/2020/02/08/fundamentals_of_compiling_frontend.html">图片来源</a></p>
<p>高级语言需要经过以上步骤才能被计算机识别并执行，ast 就是前端（编译原理上的“前端”）的产物，解释型语言的后端往往被虚拟机替代了，不会直接生成二进制文件。ast 包含了代码的全部信息，按一定规则解析 ast 就可以得到目标程序，可以说 ast 就是“结构化”后的代码。</p>
<p><img src="http://qiankunli.github.io/public/upload/basic/javascript_ast.png" alt="javascript_ast"><br><a href="http://qiankunli.github.io/2020/02/08/fundamentals_of_compiling_frontend.html">图片来源</a></p>
<h3 id="js-与-ts-的区别"><a href="#js-与-ts-的区别" class="headerlink" title="js 与 ts 的区别"></a>js 与 ts 的区别</h3><p><del>没啥区别</del></p>
<p>不能说十分相似只能说完全一样！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./add-ast.png" alt="add-ast"></p>
<p>然而 ts 多了类型系统，所以在 ast 上也会有相应的结点来体现，比如</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"><span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./ts-ast.png" alt="ts-ast"></p>
<p>这里 ts 的 ast 是基于 ts 本身编译器的 compile api 来实现的，所以结构上和 js 的会有些不同。(这里 js 用的 babel 的 parser，基于<a href="https://github.com/acornjs/acorn/tree/master/acorn">acorn</a>)</p>
<p>当然也可以用 js 来处理 ts 的项目，毕竟本质上就是一些字符串而已，但是 ts 提供了独立的编译 api，可以更方便地处理文件<del>(懒得搞 js)</del></p>
<h3 id="前端应用"><a href="#前端应用" class="headerlink" title="前端应用"></a>前端应用</h3><ol>
<li><p>es6 转 es5（不完全可以）</p>
</li>
<li><p><del>偷懒</del>语法转换（babel-plugin-import 这类）</p>
</li>
<li><p>引用分析</p>
</li>
<li><p><del>小程序热更新</del></p>
</li>
</ol>
<h2 id="示例：BigInt-babel-插件"><a href="#示例：BigInt-babel-插件" class="headerlink" title="示例：BigInt babel 插件"></a>示例：BigInt babel 插件</h2><p><a href="https://github.com/dreamhuan/bigint">https://github.com/dreamhuan/bigint</a></p>
<h3 id="开源的完整版"><a href="#开源的完整版" class="headerlink" title="开源的完整版"></a>开源的完整版</h3><p><a href="https://github.com/dreamhuan/bigint/blob/master/babel-plugin-transform-bigint.js">见代码</a></p>
<h3 id="手动简陋版"><a href="#手动简陋版" class="headerlink" title="手动简陋版"></a>手动简陋版</h3><p><a href="https://github.com/dreamhuan/bigint/blob/master/index.js">见代码</a></p>
<h2 id="小工具：静态引用分析"><a href="#小工具：静态引用分析" class="headerlink" title="小工具：静态引用分析"></a>小工具：静态引用分析</h2><p><a href="https://github.com/dreamhuan/next-analysis">https://github.com/dreamhuan/next-analysis</a></p>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ol>
<li>找出项目中没有被引用的文件</li>
<li>找出页面的组件引用情况</li>
<li>找出组件的被引用情况</li>
</ol>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="/./next-analysis.png" alt="next-analysis"></p>
<h2 id="常用链接-参考文章"><a href="#常用链接-参考文章" class="headerlink" title="常用链接 &amp; 参考文章"></a>常用链接 &amp; 参考文章</h2><ul>
<li><a href="https://astexplorer.net/">AST Explorer</a></li>
<li><a href="https://ts-ast-viewer.com/">TypeScript AST Viewer</a></li>
<li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md">Babel 插件手册</a></li>
<li><a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API">Using the Compiler API</a></li>
<li><a href="https://chengyuming.cn/views/webpack/AST.html">AST 团队分享</a></li>
<li><a href="https://learning-notes.mistermicheels.com/javascript/typescript/compiler-api/">Compiler API (TypeScript)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30360931">手把手教写 TypeScript Transformer Plugin</a></li>
<li><a href="https://daief.tech/2019-02-01/the-first-time-i-learn-ast.html">初识 AST</a></li>
<li><a href="http://qiankunli.github.io/2020/02/08/fundamentals_of_compiling_frontend.html">《编译原理之美》笔记——前端部分</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34191831">微信小程序也要强行热更代码，鹅厂不服你来肛我呀</a></li>
</ul>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数</title>
    <url>/2021/01/02/%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<p>IEEE 754</p>
<span id="more"></span>

<p>c++浮点数类型有 float 和 double，js 的 number 采用 double 的存储方式。（这里提 c++是因为 v8 底层是 c++，其实我所知道的语言的浮点数都遵循 IEEE 754 标准，所以啥语言都一样，要是来个不遵循的反而不合直觉）</p>
<p>按照标准 IEEE 754 规定，浮点数的表示方法为：</p>
<blockquote>
<p><code>(-1)^s x M x 2^E</code> (<code>^</code>表示指数而不是异或，下同) 。</p>
</blockquote>
<ul>
<li>(-1)^s 表示符号位，正数 s&#x3D;0，负数 s&#x3D;1</li>
<li>M 是有效数字 1≤M ＜ 2</li>
<li>E 是指数位</li>
</ul>
<p>float 为 32 位二进制数表示，最高的 1 位是符号位 s，接着的 8 位是指数 E，剩下的 23 位为有效数字 M。1+8+23&#x3D;32，double 就是 1+11+52&#x3D;64，可以看到指数位和有效数字位都比 float 大了，所以整体可表示的数值也大了很多。但是规则是一样的。</p>
<p>接下来就说 double 的规则<br><img src="/./1.jpg" alt="double"><br>sign 1 位比特, exponent 11 位比特, significand 52 比特.<br>s 表示符号位<br>exponent 并不是公式中的 E, 而是 E+1023（因为 E 可以为负数）.<br>前面说过，1≤M&lt;2，也就是说，M 可以写成 1.xxx 的形式，其中 xxx 表示小数部分 . significand 保存的就是小数部分.当 exponent 全为 1, significand 部分全为 0 时, 表示 Infinity</p>
<p>js 的 number 的以下几个常量说下计算方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span> === <span class="number">9007199254740991</span>;</span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_SAFE_INTEGER</span> === -<span class="number">9007199254740991</span>;</span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> === <span class="number">1.7976931348623157e308</span>;</span><br><span class="line"><span class="title class_">Number</span>.<span class="property">MIN_VALUE</span> === <span class="number">5e-324</span>;</span><br></pre></td></tr></table></figure>

<p>MAX_SAFE_INTEGER，最大安全整数，表示再这个范围内用于计算时不会有精度丢失。其实就是把 52 个有效数字位全部用上的最大值，2^53-1，再大一点就 M 部分就放不下了</p>
<p>Number.MAX_VALUE，最大数 (2^53 - 1) x 2^971<br><img src="/./2.jpg" alt="double"></p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>front-end</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈跨域</title>
    <url>/2018/01/16/%E8%B0%88%E8%B0%88%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>详解前端跨域的概念和解决方案。</p>
<span id="more"></span>

<h1 id="何为跨域，为何跨域？"><a href="#何为跨域，为何跨域？" class="headerlink" title="何为跨域，为何跨域？"></a>何为跨域，为何跨域？</h1><h2 id="何为跨域"><a href="#何为跨域" class="headerlink" title="何为跨域"></a>何为跨域</h2><p> 一言以蔽之：</p>
<blockquote>
<p>只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。</p>
</blockquote>
<p>比如http与https，80端口与81端口，a.com与b.com以上三个情况的各种组合都是不同域的，互相之前的请求就是跨域请求</p>
<h2 id="浏览器同源策略"><a href="#浏览器同源策略" class="headerlink" title="浏览器同源策略"></a>浏览器同源策略</h2><p>那所谓的跨域是怎么产生的呢？那么就要提到同源策略了。浏览器为了安全考虑就制定了一个同源策略，同源策略又分为以下几种</p>
<ol>
<li>DOM同源策略：禁止对不同源页面DOM进行操作。这里主要场景是iframe跨域的情况，不同域名的iframe是限制互相访问的。</li>
<li>XmlHttpRequest同源策略：禁止使用XHR对象向不同源的服务器地址发起HTTP请求。就是所谓的ajax请求，生活中这个场景较多见。</li>
</ol>
<p><strong>这里主要介绍ajax跨域的情况。</strong></p>
<p>另外，img，script，link，iframe等标签的src都是不受同源策略约束的，可以自由引用不同源的内容。<br>想想要是没有同源策略，a网站上的js就可以操作b网站上的DOM并且可以发起请求，这将是一个灾难！所以一切为了安全…</p>
<p><strong>同源策略更详细的介绍：</strong></p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">浏览器同源政策及其规避方法</a></li>
<li><a href="http://changsiyuan.github.io/2015/10/30/cross-domain/">同源策略详解</a></li>
</ul>
<h2 id="为何跨域"><a href="#为何跨域" class="headerlink" title="为何跨域"></a>为何跨域</h2><p>总有这样那样的原因使我们想要请求别的网站的数据或者和别的网页交互。这个原因可以是</p>
<ol>
<li>前后端分离开发，前端用了webpack-dev-server必然有个和后端不同的端口…</li>
<li>想要获取其他网站的内容比如教务处请求课表啊成绩啊之类的</li>
</ol>
<h1 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h1><p>首先明确一点<strong>对于端口和协议的不同，只能通过后台来解决。</strong></p>
<p>既然提到解决方案当然要上代码，但是作为demo代码比较简略。后端使用nodejs的Express，浏览器用chrome。<br>本地服务器模拟不同域名最简单粗暴的方式是改host。。。文件位于<code>C:\Windows\System32\drivers\etc</code><br>右键hosts用记事本打开，里面长这样</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Copyright (c) 1993-2009 Microsoft Corp.</span><br><span class="line">#</span><br><span class="line"># This is a sample HOSTS file used by Microsoft TCP/IP for Windows.</span><br><span class="line">#</span><br><span class="line"># This file contains the mappings of IP addresses to host names. Each</span><br><span class="line"># entry should be kept on an individual line. The IP address should</span><br><span class="line"># be placed in the first column followed by the corresponding host name.</span><br><span class="line"># The IP address and the host name should be separated by at least one</span><br><span class="line"># space.</span><br><span class="line">#</span><br><span class="line"># Additionally, comments (such as these) may be inserted on individual</span><br><span class="line"># lines or following the machine name denoted by a &#x27;#&#x27; symbol.</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line">#      102.54.94.97     rhino.acme.com          # source server</span><br><span class="line">#       38.25.63.10     x.acme.com              # x client host</span><br><span class="line"></span><br><span class="line"># localhost name resolution is handled within DNS itself.</span><br><span class="line"># 127.0.0.1       localhost</span><br><span class="line"># ::1             localhost</span><br></pre></td></tr></table></figure>

<p>把测试的几个域名指向本地，也就是在这个文件的最后面加上以下几行内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">127.0.0.1 www.aaa.com</span><br><span class="line">127.0.0.1 www.bbb.com</span><br><span class="line">127.0.0.1 aaa.com</span><br></pre></td></tr></table></figure>

<p>简单解释就是浏览器输入后面的三个网站时会默认打开本地的服务器(输网址记得加上<code>http://</code>，不然浏览器可能默认会加上www…)。测试完之后删了就好了，别的没什么影响。<br>需要注意的是如果有ss或者ssr记得关了它，chrome走代理的话就白改了，看不懂这句话请跳过。</p>
<p>然后我们需要知道的是，所谓的跨域是不管你这个域名对应的ip是啥，只看域名，对不上就跨域（就是个字符串处理），所以可以看到我们改了host文件吧三个域名都对应到了本地服务器来实现多个域名。<br>代码在<a href="https://dreamhuan.github.io/2018/01/16/%E8%B0%88%E8%B0%88%E8%B7%A8%E5%9F%9F/">这里</a>，当然本文中我也会贴代码。。。</p>
<p>host的不同源环境配置完成，现在我们要打代码了，就是发几个跨域请求…<br>新建个文件夹crossorigin，命令行进去输入<code>npm init -y</code>初始化项目，然后<code>yarn add express</code>安装依赖<br>新建src文件夹，然后建立相应文件并写代码。</p>
<p>src&#x2F;server1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./public&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8080</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/iv1/hello&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hello server 1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>src&#x2F;server2.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8081</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/iv1/hello&#x27;</span>,<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hello server 2&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>src&#x2F;public&#x2F;index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>跨域<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;ajax1(&#x27;http://www.aaa.com:8080/iv1/hello&#x27;)&quot;</span>&gt;</span>www.aaa.com:8080<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;ajax1(&#x27;http://aaa.com:8080/iv1/hello&#x27;)&quot;</span>&gt;</span>aaa.com:8080<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;ajax1(&#x27;http://www.bbb.com:8080/iv1/hello&#x27;)&quot;</span>&gt;</span>www.bbb.com:8080<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;ajax1(&#x27;http://www.aaa.com:8081/iv1/hello&#x27;)&quot;</span>&gt;</span>www.aaa.com:8081<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;ajax1(&#x27;http://127.0.0.1:8080/iv1/hello&#x27;)&quot;</span>&gt;</span>127.0.0.1:8080<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">ajax</span>(<span class="params">url</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url)</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="property">onload</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">status</span>)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">send</span>()</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">ajax1</span>(<span class="params">url</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fetch</span>(url)</span></span><br><span class="line"><span class="language-javascript">            .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>())</span></span><br><span class="line"><span class="language-javascript">            .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span><br><span class="line"><span class="language-javascript">            &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码很简单，js部分开了两个服务器监听8080，8081端口，并用Express的static设置了静态目录，（就是说访问localhost:8080就是显示public&#x2F;index.html）然后后端挂了个&#x2F;iv1&#x2F;hello的get接口，返回字符串‘hello server 1’，‘hello server 2’，html的代码就是放了几个按钮用于发起ajax请求，这里写了xhr和fetch两个方式，这是目前主流两种ajax方式。好了，在package.json的scripts里面加两个命令”server1”: “node .&#x2F;src&#x2F;server1.js”,”server2”: “node .&#x2F;src&#x2F;server2.js”，并执行npm run server1，npm run server2。访问<a href="http://www.aaa.com:8080/">http://www.aaa.com:8080/</a> 这个域名等效于localhost:8080 。因为我们host做了映射直接访问127.0.0.1了。打开控制台看console界面，然后依次点击5个按钮，可以看到，除了点第一个按钮出来了结果，其他几个都是报错说我们跨域了。那么，我们的旅程现在开始。</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>可以看到主要的报错信息是这样滴，上面那个是fetch的报错信息，下面是xhr的报错信息。</p>
<blockquote>
<p>Failed to load <a href="http://aaa.com:8080/iv1/hello">http://aaa.com:8080/iv1/hello</a>: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘<a href="http://www.aaa.com:8080/">http://www.aaa.com:8080</a>‘ is therefore not allowed access. If an opaque response serves your needs, set the request’s mode to ‘no-cors’ to fetch the resource with CORS disabled.</p>
</blockquote>
<p>　</p>
<blockquote>
<p>Failed to load <a href="http://aaa.com:8080/iv1/hello">http://aaa.com:8080/iv1/hello</a>: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘<a href="http://www.aaa.com:8080/">http://www.aaa.com:8080</a>‘ is therefore not allowed access.</p>
</blockquote>
<p>划重点<code>Origin &#39;http://www.aaa.com:8080&#39; is therefore not allowed access.</code>是说 “<a href="http://www.aaa.com:8080”">http://www.aaa.com:8080”</a> 这个源不被允许访问“<a href="http://aaa.com:8080/iv1/hello%E2%80%9D%E3%80%82">http://aaa.com:8080/iv1/hello”。</a> 那么<code>No &#39;Access-Control-Allow-Origin&#39; header</code>这是啥呢？它是说服务器上没有设置过这个头字段(header)。这也就引出了CORS的概念。CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）阮一峰的<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">这篇文章</a>把CORS的细节讲的十分透彻了，我这里就不赘述，我就简单提一下代码怎么写，同时你也会明白怎么就莫名其妙的引出CORS了。</p>
<p>说出来你可能不信，代码十分简单。。。</p>
<p>在src&#x2F;server1.js的app.get之前加上以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>,<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>是不是看到了熟悉的’Access-Control-Allow-Origin’。其实这就是说web官方看你们那么想跨域，就制定了一个标准，要是后端的响应头设置了’Access-Control-Allow-Origin’这个字段，那么就允许你们跨域请求这个接口。<br>当然，一般情况一行代码不够用，emmmm…一行不够就三行喽。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="keyword">function</span> (<span class="params">req, res, next</span>) &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>); <span class="comment">//允许哪些url可以跨域请求到本域，*表示全部</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET, POST&quot;</span>); <span class="comment">//允许的请求方法，一般是GET,POST,PUT,DELETE,OPTIONS</span></span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;x-requested-with,content-type,Token&quot;</span>); <span class="comment">//允许哪些请求头可以跨域</span></span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注释很详细啦~，一句话总结：CORS是为了跨域制定的标准，只要后端设置了响应头，符合要求的请求就可以跨域请求成功。<br>总结完加个ps：CORS需要浏览器本身支持，但是现代浏览器都是支持的，所以就提一下。（IE已被现代浏览器除名…）</p>
<p>pps：CORS默认不会带cookie，要带cookie的话js和服务端都要做额外设置。。。<br>对于客户端，我们还是正常使用xhr对象发送ajax请求，但是要设置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.<span class="property">withCredentials</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>对于服务器端，需要在 response header中设置如下两个字段（注意第一个必须是具体域名，不能是*）:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Origin</span>: <span class="attr">http</span>:<span class="comment">//www.yourhost.com</span></span><br><span class="line"><span class="title class_">Access</span>-<span class="title class_">Control</span>-<span class="title class_">Allow</span>-<span class="title class_">Credentials</span>:<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>相对于CORS有标准的支持，jsonp可以说只是一个小技巧。只不过这个技巧用多了就发现挺顺手然后大家都用了。。。<br>前文提到scrip标签的src引用的内容不受同源策略限制，那我们就手动创建一个script标签发起一个get请求，并且把某个函数名f作为参数传过去，并在全局定义一个f函数。后端返回一串字符串，字符串的形式是函数调用”f(data)”，script标签请求完后直接执行js就会执行f(data)，然后就完成了跨域数据请求。  </p>
<p>好吧，是有点绕。。。我们实践下，这次打开server2.js，之前CORS的代码写到了server1，server2是无法跨域的。</p>
<p>src&#x2F;server2.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8081</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/iv1/hello&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hello server 2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/iv1/jsonp&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> funName = req.<span class="property">query</span>.<span class="property">funName</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">b</span>: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">`<span class="subst">$&#123;funName&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>public&#x2F;index.html最后在加两个按钮，然后script里面加个函数。（第一个按钮是测试跨域的）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;ajax(&#x27;http://www.bbb.com:8081/iv1/hello&#x27;)&quot;</span>&gt;</span>get www.bbb.com:8081<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;jsonp()&quot;</span>&gt;</span>jsonp www.bbb.com:8081<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    ...</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> url = <span class="string">&#x27;http://www.bbb.com:8081/iv1/jsonp?funName=logData&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">logData</span> = <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;src&#x27;</span>, url);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">appendChild</span>(script);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后访问<a href="http://www.aaa.com:8080/">http://www.aaa.com:8080/</a>，点击最后两个请求，可以看到第一个被浏览器拦截说是跨域了，第二个正确log出了数据。</p>
<p>jsonp大概就是这样，人为伪造一个script标签发起请求并返回函数包裹数据的形式，前端拿到返回值直接当做js代码执行了。jsonp在CORS出现之前可是顶了半边天。。。但是它的限制也很大，首先最致命的事只支持get请求，毕竟本来就只是script标签的src属性发起的请求。。。然后就是后端要为jsonp类型的请求专门写一个接口。因为正常接口直接返回数据的话jsonp的接口需要返回函数名包裹数据的形式。</p>
<h2 id="后端代理"><a href="#后端代理" class="headerlink" title="后端代理"></a>后端代理</h2><p>这个方法就比较简单粗暴了。首先明确一点是一个简单请求虽然跨域了但是他是真的到达后端的，跨域的报错是浏览器拦截了那个请求的返回。对于非简单请求，浏览器会发一个方法为OPTIONS的请求，主要是去问问服务器是否允许跨域，不允许的话浏览器就报错了，允许的话浏览器就会发起正式的请求。可以看到，这一切都是浏览器的锅。。。所有的跨域都是浏览器的规则，那么就意味着我服务端发送的请求时可以得到正常响应的，于是就有了如下骚操作：host a的网页请求host a的某个接口，那个接口去请求host b的某个接口，并把请求的结果告诉host a的网页（浏览器）。对浏览器来说一切都是和自己家的后端交互，至于跨域请求那就让后端帮我们去请求并把结果告诉我就好啦，这就是所谓的代理。。。</p>
<p>上代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;ajax(&#x27;http://www.aaa.com:8080/iv1/proxy&#x27;)&quot;</span>&gt;</span>www.aaa.com:8080后端代理www.bbb.com:8081<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>src&#x2F;server1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">...</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/iv1/proxy&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    http.<span class="title function_">get</span>(<span class="string">&#x27;http://www.bbb.com:8081/iv1/hello&#x27;</span>, <span class="keyword">function</span> (<span class="params">_req, _res</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        _req.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">chunk</span>) &#123;</span><br><span class="line">            data += chunk;</span><br><span class="line">        &#125;);</span><br><span class="line">        _req.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            res.<span class="title function_">send</span>(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>可以看到html部分就是多了个按钮向自己的后端的代理接口发了个请求，后端首先引入了http库（nodejs自带）然后用http向目标url发了个get请求并在请求完成后把数据返回给前端。点击最后一个按钮可以看到数据成功打印在了控制台。</p>
<p>这个后端代理的好处就是完全不管啥同源策略什么的，暴力请求，请求玩数据扔给前端就行，emmmmm本质上就是个爬虫…</p>
]]></content>
      <categories>
        <category>front-end</category>
      </categories>
      <tags>
        <tag>front-end</tag>
        <tag>跨域</tag>
        <tag>jsonp</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
</search>
